
RTOS_Driven_Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000233c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a0  00800060  0000233c  000023d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000482  00800100  00800100  00002470  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002470  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000024a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004c8  00000000  00000000  000024dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005624  00000000  00000000  000029a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001359  00000000  00000000  00007fc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003033  00000000  00000000  00009321  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000dfc  00000000  00000000  0000c354  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000179a  00000000  00000000  0000d150  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004727  00000000  00000000  0000e8ea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000490  00000000  00000000  00013011  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c8 05 	jmp	0xb90	; 0xb90 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 c7 0f 	jmp	0x1f8e	; 0x1f8e <__vector_10>
      2c:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e3       	ldi	r30, 0x3C	; 60
      68:	f3 e2       	ldi	r31, 0x23	; 35
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 30       	cpi	r26, 0x00	; 0
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 38       	cpi	r26, 0x82	; 130
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8d 02 	call	0x51a	; 0x51a <main>
      8a:	0c 94 9c 11 	jmp	0x2338	; 0x2338 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <LM35>:
u8 enteredPassword[4];
u8 passwordIndex = 0;

//-------------------------------------------------------------
//-------------------------------------------------------------
void LM35(void){
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	00 d0       	rcall	.+0      	; 0x98 <LM35+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <LM35+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
	u16 adc = 0 ;
	f32 temp = 0 ;
      9e:	19 82       	std	Y+1, r1	; 0x01
      a0:	1a 82       	std	Y+2, r1	; 0x02
      a2:	1b 82       	std	Y+3, r1	; 0x03
      a4:	1c 82       	std	Y+4, r1	; 0x04
	
	while (1)
	{
		if (xSemaphoreTake( LCD, 100 ) == HIGH && PassCorrect)
      a6:	20 e0       	ldi	r18, 0x00	; 0
      a8:	44 e6       	ldi	r20, 0x64	; 100
      aa:	50 e0       	ldi	r21, 0x00	; 0
      ac:	60 e0       	ldi	r22, 0x00	; 0
      ae:	70 e0       	ldi	r23, 0x00	; 0
      b0:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
      b4:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
      b8:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
      bc:	81 30       	cpi	r24, 0x01	; 1
      be:	e1 f5       	brne	.+120    	; 0x138 <LM35+0xa6>
      c0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <PassCorrect>
      c4:	88 23       	and	r24, r24
      c6:	c1 f1       	breq	.+112    	; 0x138 <LM35+0xa6>
		{
			adc = ADC_u16ReadChannel(ADC_0) ;
      c8:	80 e0       	ldi	r24, 0x00	; 0
      ca:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <ADC_u16ReadChannel>
			temp = (f32) adc*500/1024 ;
      ce:	bc 01       	movw	r22, r24
      d0:	80 e0       	ldi	r24, 0x00	; 0
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	0e 94 2c 10 	call	0x2058	; 0x2058 <__floatunsisf>
      d8:	20 e0       	ldi	r18, 0x00	; 0
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	4a ef       	ldi	r20, 0xFA	; 250
      de:	53 e4       	ldi	r21, 0x43	; 67
      e0:	0e 94 97 10 	call	0x212e	; 0x212e <__mulsf3>
      e4:	20 e0       	ldi	r18, 0x00	; 0
      e6:	30 e0       	ldi	r19, 0x00	; 0
      e8:	40 e8       	ldi	r20, 0x80	; 128
      ea:	5a e3       	ldi	r21, 0x3A	; 58
      ec:	0e 94 97 10 	call	0x212e	; 0x212e <__mulsf3>
      f0:	69 83       	std	Y+1, r22	; 0x01
      f2:	7a 83       	std	Y+2, r23	; 0x02
      f4:	8b 83       	std	Y+3, r24	; 0x03
      f6:	9c 83       	std	Y+4, r25	; 0x04
			xQueueSend( Queue1, &temp, 100 );
      f8:	20 e0       	ldi	r18, 0x00	; 0
      fa:	44 e6       	ldi	r20, 0x64	; 100
      fc:	50 e0       	ldi	r21, 0x00	; 0
      fe:	be 01       	movw	r22, r28
     100:	6f 5f       	subi	r22, 0xFF	; 255
     102:	7f 4f       	sbci	r23, 0xFF	; 255
     104:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <Queue1>
     108:	90 91 7f 05 	lds	r25, 0x057F	; 0x80057f <Queue1+0x1>
     10c:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
			
			LCD_voidGotoxy(0, 1);
     110:	61 e0       	ldi	r22, 0x01	; 1
     112:	80 e0       	ldi	r24, 0x00	; 0
     114:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
			LCD_voidSendString("TEMP ");
     118:	86 e6       	ldi	r24, 0x66	; 102
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
			
			LCD_voidGotoxy(5, 1);
     120:	61 e0       	ldi	r22, 0x01	; 1
     122:	85 e0       	ldi	r24, 0x05	; 5
     124:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
			LCD_voidSendNumber(temp);
     128:	69 81       	ldd	r22, Y+1	; 0x01
     12a:	7a 81       	ldd	r23, Y+2	; 0x02
     12c:	8b 81       	ldd	r24, Y+3	; 0x03
     12e:	9c 81       	ldd	r25, Y+4	; 0x04
     130:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <__fixunssfsi>
     134:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_voidSendNumber>
		}
		xSemaphoreGive( LCD );
     138:	20 e0       	ldi	r18, 0x00	; 0
     13a:	40 e0       	ldi	r20, 0x00	; 0
     13c:	50 e0       	ldi	r21, 0x00	; 0
     13e:	60 e0       	ldi	r22, 0x00	; 0
     140:	70 e0       	ldi	r23, 0x00	; 0
     142:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     146:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     14a:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
		vTaskDelay(100);
     14e:	84 e6       	ldi	r24, 0x64	; 100
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vTaskDelay>
	}
     156:	a7 cf       	rjmp	.-178    	; 0xa6 <LM35+0x14>

00000158 <Terminal>:
}
//-------------------------------------------------------------
void Terminal(void)
{
     158:	cf 93       	push	r28
     15a:	df 93       	push	r29
     15c:	1f 92       	push	r1
     15e:	cd b7       	in	r28, 0x3d	; 61
     160:	de b7       	in	r29, 0x3e	; 62
	u8 val;
	u8 passwordCorrect = 0;
     162:	19 82       	std	Y+1, r1	; 0x01

	while (1)
	{
		if (xSemaphoreTake(LCD, 100) == pdTRUE)
     164:	20 e0       	ldi	r18, 0x00	; 0
     166:	44 e6       	ldi	r20, 0x64	; 100
     168:	50 e0       	ldi	r21, 0x00	; 0
     16a:	60 e0       	ldi	r22, 0x00	; 0
     16c:	70 e0       	ldi	r23, 0x00	; 0
     16e:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     172:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     176:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
     17a:	81 30       	cpi	r24, 0x01	; 1
     17c:	71 f5       	brne	.+92     	; 0x1da <Terminal+0x82>
		{
			val = UART_u8RX();
     17e:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <UART_u8RX>
			enteredPassword[passwordIndex++] = val;
     182:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__data_end>
     186:	91 e0       	ldi	r25, 0x01	; 1
     188:	9e 0f       	add	r25, r30
     18a:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__data_end>
     18e:	f0 e0       	ldi	r31, 0x00	; 0
     190:	e6 58       	subi	r30, 0x86	; 134
     192:	fa 4f       	sbci	r31, 0xFA	; 250
     194:	80 83       	st	Z, r24

			if (passwordIndex >= 4)
     196:	94 30       	cpi	r25, 0x04	; 4
     198:	00 f1       	brcs	.+64     	; 0x1da <Terminal+0x82>
			{
				passwordIndex = 0;
     19a:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_end>

				if (memcmp(enteredPassword, correctPassword, 4) == 0) passwordCorrect = 1;
     19e:	44 e0       	ldi	r20, 0x04	; 4
     1a0:	50 e0       	ldi	r21, 0x00	; 0
     1a2:	60 e6       	ldi	r22, 0x60	; 96
     1a4:	70 e0       	ldi	r23, 0x00	; 0
     1a6:	8a e7       	ldi	r24, 0x7A	; 122
     1a8:	95 e0       	ldi	r25, 0x05	; 5
     1aa:	0e 94 86 11 	call	0x230c	; 0x230c <memcmp>
     1ae:	89 2b       	or	r24, r25
     1b0:	19 f4       	brne	.+6      	; 0x1b8 <Terminal+0x60>
     1b2:	81 e0       	ldi	r24, 0x01	; 1
     1b4:	89 83       	std	Y+1, r24	; 0x01
     1b6:	01 c0       	rjmp	.+2      	; 0x1ba <Terminal+0x62>
				else passwordCorrect = 0;
     1b8:	19 82       	std	Y+1, r1	; 0x01
				
				xQueueSend(Queue2, &passwordCorrect, 100);
     1ba:	20 e0       	ldi	r18, 0x00	; 0
     1bc:	44 e6       	ldi	r20, 0x64	; 100
     1be:	50 e0       	ldi	r21, 0x00	; 0
     1c0:	be 01       	movw	r22, r28
     1c2:	6f 5f       	subi	r22, 0xFF	; 255
     1c4:	7f 4f       	sbci	r23, 0xFF	; 255
     1c6:	80 91 78 05 	lds	r24, 0x0578	; 0x800578 <Queue2>
     1ca:	90 91 79 05 	lds	r25, 0x0579	; 0x800579 <Queue2+0x1>
     1ce:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
				
				vTaskSuspend(NULL);
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskSuspend>
			}
		}
		xSemaphoreGive(LCD);
     1da:	20 e0       	ldi	r18, 0x00	; 0
     1dc:	40 e0       	ldi	r20, 0x00	; 0
     1de:	50 e0       	ldi	r21, 0x00	; 0
     1e0:	60 e0       	ldi	r22, 0x00	; 0
     1e2:	70 e0       	ldi	r23, 0x00	; 0
     1e4:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     1e8:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     1ec:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
		
	}
     1f0:	b9 cf       	rjmp	.-142    	; 0x164 <Terminal+0xc>

000001f2 <Screen>:
}

//-------------------------------------------------------------
void Screen(void)
{
     1f2:	cf 93       	push	r28
     1f4:	df 93       	push	r29
     1f6:	1f 92       	push	r1
     1f8:	cd b7       	in	r28, 0x3d	; 61
     1fa:	de b7       	in	r29, 0x3e	; 62
	u8 result;
	
	while (1)
	{
		if (xSemaphoreTake(LCD, 100) == pdTRUE)
     1fc:	20 e0       	ldi	r18, 0x00	; 0
     1fe:	44 e6       	ldi	r20, 0x64	; 100
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	60 e0       	ldi	r22, 0x00	; 0
     204:	70 e0       	ldi	r23, 0x00	; 0
     206:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     20a:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     20e:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
     212:	81 30       	cpi	r24, 0x01	; 1
     214:	99 f7       	brne	.-26     	; 0x1fc <Screen+0xa>
		{
			
			
			if (xQueueReceive(Queue2, &result, 100) == pdTRUE)
     216:	20 e0       	ldi	r18, 0x00	; 0
     218:	44 e6       	ldi	r20, 0x64	; 100
     21a:	50 e0       	ldi	r21, 0x00	; 0
     21c:	be 01       	movw	r22, r28
     21e:	6f 5f       	subi	r22, 0xFF	; 255
     220:	7f 4f       	sbci	r23, 0xFF	; 255
     222:	80 91 78 05 	lds	r24, 0x0578	; 0x800578 <Queue2>
     226:	90 91 79 05 	lds	r25, 0x0579	; 0x800579 <Queue2+0x1>
     22a:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
     22e:	81 30       	cpi	r24, 0x01	; 1
     230:	41 f5       	brne	.+80     	; 0x282 <Screen+0x90>
			{
				if (result == 1)
     232:	89 81       	ldd	r24, Y+1	; 0x01
     234:	81 30       	cpi	r24, 0x01	; 1
     236:	81 f4       	brne	.+32     	; 0x258 <Screen+0x66>
				{
					PassCorrect = 1;
     238:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <PassCorrect>
					DIO_voidSetPinVal(DIO_PORTC, DIO_PIN0, HIGH);
     23c:	41 e0       	ldi	r20, 0x01	; 1
     23e:	60 e0       	ldi	r22, 0x00	; 0
     240:	82 e0       	ldi	r24, 0x02	; 2
     242:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>

					LCD_voidGotoxy(0, 0);
     246:	60 e0       	ldi	r22, 0x00	; 0
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
					LCD_voidSendString("WELCOME  ");
     24e:	8c e6       	ldi	r24, 0x6C	; 108
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
     256:	15 c0       	rjmp	.+42     	; 0x282 <Screen+0x90>
				}
				else
				{
					LCD_voidGotoxy(0, 0);
     258:	60 e0       	ldi	r22, 0x00	; 0
     25a:	80 e0       	ldi	r24, 0x00	; 0
     25c:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
					LCD_voidSendString("WRONG PASSWORD!");
     260:	86 e7       	ldi	r24, 0x76	; 118
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
					LCD_voidGotoxy(0, 1);
     268:	61 e0       	ldi	r22, 0x01	; 1
     26a:	80 e0       	ldi	r24, 0x00	; 0
     26c:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
					LCD_voidSendString("               ");
     270:	86 e8       	ldi	r24, 0x86	; 134
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>

					DIO_voidSetPinVal(DIO_PORTC, DIO_PIN1, HIGH);
     278:	41 e0       	ldi	r20, 0x01	; 1
     27a:	61 e0       	ldi	r22, 0x01	; 1
     27c:	82 e0       	ldi	r24, 0x02	; 2
     27e:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
				}
			}
			xSemaphoreGive(LCD);
     282:	20 e0       	ldi	r18, 0x00	; 0
     284:	40 e0       	ldi	r20, 0x00	; 0
     286:	50 e0       	ldi	r21, 0x00	; 0
     288:	60 e0       	ldi	r22, 0x00	; 0
     28a:	70 e0       	ldi	r23, 0x00	; 0
     28c:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     290:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     294:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
			vTaskSuspend(NULL);
     298:	80 e0       	ldi	r24, 0x00	; 0
     29a:	90 e0       	ldi	r25, 0x00	; 0
     29c:	0e 94 37 0c 	call	0x186e	; 0x186e <vTaskSuspend>
     2a0:	ad cf       	rjmp	.-166    	; 0x1fc <Screen+0xa>

000002a2 <LDR>:
	u16 adc = 0 ;
	u32 V = 0 ;
	
	while (1)
	{
		if (xSemaphoreTake( LCD, 100 ) == HIGH && PassCorrect)
     2a2:	20 e0       	ldi	r18, 0x00	; 0
     2a4:	44 e6       	ldi	r20, 0x64	; 100
     2a6:	50 e0       	ldi	r21, 0x00	; 0
     2a8:	60 e0       	ldi	r22, 0x00	; 0
     2aa:	70 e0       	ldi	r23, 0x00	; 0
     2ac:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     2b0:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     2b4:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
     2b8:	81 30       	cpi	r24, 0x01	; 1
     2ba:	09 f0       	breq	.+2      	; 0x2be <LDR+0x1c>
     2bc:	5a c0       	rjmp	.+180    	; 0x372 <LDR+0xd0>
     2be:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <PassCorrect>
     2c2:	88 23       	and	r24, r24
     2c4:	09 f4       	brne	.+2      	; 0x2c8 <LDR+0x26>
     2c6:	55 c0       	rjmp	.+170    	; 0x372 <LDR+0xd0>
		{
			adc = ADC_u16ReadChannel(ADC_1) ;
     2c8:	81 e0       	ldi	r24, 0x01	; 1
     2ca:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <ADC_u16ReadChannel>
			V = (adc * 5) / 1023;
     2ce:	9c 01       	movw	r18, r24
     2d0:	22 0f       	add	r18, r18
     2d2:	33 1f       	adc	r19, r19
     2d4:	22 0f       	add	r18, r18
     2d6:	33 1f       	adc	r19, r19
     2d8:	82 0f       	add	r24, r18
     2da:	93 1f       	adc	r25, r19
     2dc:	6f ef       	ldi	r22, 0xFF	; 255
     2de:	73 e0       	ldi	r23, 0x03	; 3
     2e0:	0e 94 50 11 	call	0x22a0	; 0x22a0 <__udivmodhi4>
			
			if (V > 3)
     2e4:	64 30       	cpi	r22, 0x04	; 4
     2e6:	71 05       	cpc	r23, r1
     2e8:	98 f0       	brcs	.+38     	; 0x310 <LDR+0x6e>
			{
				LCD_voidGotoxy(8, 0);
     2ea:	60 e0       	ldi	r22, 0x00	; 0
     2ec:	88 e0       	ldi	r24, 0x08	; 8
     2ee:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString("NO LAMPs");
     2f2:	86 e9       	ldi	r24, 0x96	; 150
     2f4:	90 e0       	ldi	r25, 0x00	; 0
     2f6:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN6, LOW);
     2fa:	40 e0       	ldi	r20, 0x00	; 0
     2fc:	66 e0       	ldi	r22, 0x06	; 6
     2fe:	82 e0       	ldi	r24, 0x02	; 2
     300:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN7, LOW);
     304:	40 e0       	ldi	r20, 0x00	; 0
     306:	67 e0       	ldi	r22, 0x07	; 7
     308:	82 e0       	ldi	r24, 0x02	; 2
     30a:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
     30e:	31 c0       	rjmp	.+98     	; 0x372 <LDR+0xd0>
			}else if(V > 1.5)
     310:	80 e0       	ldi	r24, 0x00	; 0
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	0e 94 2c 10 	call	0x2058	; 0x2058 <__floatunsisf>
     318:	20 e0       	ldi	r18, 0x00	; 0
     31a:	30 e0       	ldi	r19, 0x00	; 0
     31c:	40 ec       	ldi	r20, 0xC0	; 192
     31e:	5f e3       	ldi	r21, 0x3F	; 63
     320:	0e 94 92 10 	call	0x2124	; 0x2124 <__gesf2>
     324:	18 16       	cp	r1, r24
     326:	9c f4       	brge	.+38     	; 0x34e <LDR+0xac>
			{
				LCD_voidGotoxy(8, 0);
     328:	60 e0       	ldi	r22, 0x00	; 0
     32a:	88 e0       	ldi	r24, 0x08	; 8
     32c:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString("ONE LAMP");
     330:	8f e9       	ldi	r24, 0x9F	; 159
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN6, HIGH);
     338:	41 e0       	ldi	r20, 0x01	; 1
     33a:	66 e0       	ldi	r22, 0x06	; 6
     33c:	82 e0       	ldi	r24, 0x02	; 2
     33e:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN7, LOW );
     342:	40 e0       	ldi	r20, 0x00	; 0
     344:	67 e0       	ldi	r22, 0x07	; 7
     346:	82 e0       	ldi	r24, 0x02	; 2
     348:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
     34c:	12 c0       	rjmp	.+36     	; 0x372 <LDR+0xd0>
			}else
			{
				LCD_voidGotoxy(8, 0);
     34e:	60 e0       	ldi	r22, 0x00	; 0
     350:	88 e0       	ldi	r24, 0x08	; 8
     352:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString("TWO LAMP");
     356:	88 ea       	ldi	r24, 0xA8	; 168
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN6, HIGH);
     35e:	41 e0       	ldi	r20, 0x01	; 1
     360:	66 e0       	ldi	r22, 0x06	; 6
     362:	82 e0       	ldi	r24, 0x02	; 2
     364:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
				DIO_voidSetPinVal(DIO_PORTC, DIO_PIN7, HIGH);
     368:	41 e0       	ldi	r20, 0x01	; 1
     36a:	67 e0       	ldi	r22, 0x07	; 7
     36c:	82 e0       	ldi	r24, 0x02	; 2
     36e:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
			}
		}
		xSemaphoreGive( LCD );
     372:	20 e0       	ldi	r18, 0x00	; 0
     374:	40 e0       	ldi	r20, 0x00	; 0
     376:	50 e0       	ldi	r21, 0x00	; 0
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	70 e0       	ldi	r23, 0x00	; 0
     37c:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     380:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     384:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
		vTaskDelay(100);
     388:	84 e6       	ldi	r24, 0x64	; 100
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vTaskDelay>
	}
     390:	88 cf       	rjmp	.-240    	; 0x2a2 <LDR>

00000392 <FAN>:
	}
}

//-------------------------------------------------------------
void FAN(void)
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	00 d0       	rcall	.+0      	; 0x398 <FAN+0x6>
     398:	00 d0       	rcall	.+0      	; 0x39a <FAN+0x8>
     39a:	cd b7       	in	r28, 0x3d	; 61
     39c:	de b7       	in	r29, 0x3e	; 62
	f32 T = 0;
     39e:	19 82       	std	Y+1, r1	; 0x01
     3a0:	1a 82       	std	Y+2, r1	; 0x02
     3a2:	1b 82       	std	Y+3, r1	; 0x03
     3a4:	1c 82       	std	Y+4, r1	; 0x04
	
	while (1)
	{
		if (xSemaphoreTake( LCD, 100 ) == HIGH && PassCorrect)
     3a6:	20 e0       	ldi	r18, 0x00	; 0
     3a8:	44 e6       	ldi	r20, 0x64	; 100
     3aa:	50 e0       	ldi	r21, 0x00	; 0
     3ac:	60 e0       	ldi	r22, 0x00	; 0
     3ae:	70 e0       	ldi	r23, 0x00	; 0
     3b0:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     3b4:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     3b8:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
     3bc:	81 30       	cpi	r24, 0x01	; 1
     3be:	09 f0       	breq	.+2      	; 0x3c2 <FAN+0x30>
     3c0:	9c c0       	rjmp	.+312    	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
     3c2:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <PassCorrect>
     3c6:	88 23       	and	r24, r24
     3c8:	09 f4       	brne	.+2      	; 0x3cc <FAN+0x3a>
     3ca:	97 c0       	rjmp	.+302    	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
		{
			xQueueReceive( Queue1, &T, 100 );
     3cc:	20 e0       	ldi	r18, 0x00	; 0
     3ce:	44 e6       	ldi	r20, 0x64	; 100
     3d0:	50 e0       	ldi	r21, 0x00	; 0
     3d2:	be 01       	movw	r22, r28
     3d4:	6f 5f       	subi	r22, 0xFF	; 255
     3d6:	7f 4f       	sbci	r23, 0xFF	; 255
     3d8:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <Queue1>
     3dc:	90 91 7f 05 	lds	r25, 0x057F	; 0x80057f <Queue1+0x1>
     3e0:	0e 94 a8 07 	call	0xf50	; 0xf50 <xQueueGenericReceive>
			
			if (T>35)
     3e4:	c9 80       	ldd	r12, Y+1	; 0x01
     3e6:	da 80       	ldd	r13, Y+2	; 0x02
     3e8:	eb 80       	ldd	r14, Y+3	; 0x03
     3ea:	fc 80       	ldd	r15, Y+4	; 0x04
     3ec:	20 e0       	ldi	r18, 0x00	; 0
     3ee:	30 e0       	ldi	r19, 0x00	; 0
     3f0:	4c e0       	ldi	r20, 0x0C	; 12
     3f2:	52 e4       	ldi	r21, 0x42	; 66
     3f4:	c7 01       	movw	r24, r14
     3f6:	b6 01       	movw	r22, r12
     3f8:	0e 94 92 10 	call	0x2124	; 0x2124 <__gesf2>
     3fc:	18 16       	cp	r1, r24
     3fe:	d4 f4       	brge	.+52     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
			{
				TIMER0_voidFastPWM(100) ;
     400:	84 e6       	ldi	r24, 0x64	; 100
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <TIMER0_voidFastPWM>
				
				LCD_voidGotoxy(7, 1);
     408:	61 e0       	ldi	r22, 0x01	; 1
     40a:	87 e0       	ldi	r24, 0x07	; 7
     40c:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString(" FAN ");
     410:	81 eb       	ldi	r24, 0xB1	; 177
     412:	90 e0       	ldi	r25, 0x00	; 0
     414:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				LCD_voidGotoxy(12, 1);
     418:	61 e0       	ldi	r22, 0x01	; 1
     41a:	8c e0       	ldi	r24, 0x0C	; 12
     41c:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendNumber(100);
     420:	64 e6       	ldi	r22, 0x64	; 100
     422:	70 e0       	ldi	r23, 0x00	; 0
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_voidSendNumber>
				LCD_voidSendData('%');
     42c:	85 e2       	ldi	r24, 0x25	; 37
     42e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <LCD_voidSendData>
     432:	63 c0       	rjmp	.+198    	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
			}
			else if(T>30)
     434:	20 e0       	ldi	r18, 0x00	; 0
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	40 ef       	ldi	r20, 0xF0	; 240
     43a:	51 e4       	ldi	r21, 0x41	; 65
     43c:	c7 01       	movw	r24, r14
     43e:	b6 01       	movw	r22, r12
     440:	0e 94 92 10 	call	0x2124	; 0x2124 <__gesf2>
     444:	18 16       	cp	r1, r24
     446:	dc f4       	brge	.+54     	; 0x47e <__EEPROM_REGION_LENGTH__+0x7e>
			{
				TIMER0_voidFastPWM(70)  ;
     448:	86 e4       	ldi	r24, 0x46	; 70
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <TIMER0_voidFastPWM>
				
				LCD_voidGotoxy(7, 1);
     450:	61 e0       	ldi	r22, 0x01	; 1
     452:	87 e0       	ldi	r24, 0x07	; 7
     454:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString(" FAN ");
     458:	81 eb       	ldi	r24, 0xB1	; 177
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				LCD_voidGotoxy(12, 1);
     460:	61 e0       	ldi	r22, 0x01	; 1
     462:	8c e0       	ldi	r24, 0x0C	; 12
     464:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendNumber(70);
     468:	66 e4       	ldi	r22, 0x46	; 70
     46a:	70 e0       	ldi	r23, 0x00	; 0
     46c:	80 e0       	ldi	r24, 0x00	; 0
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_voidSendNumber>
				LCD_voidSendString("% ");
     474:	87 eb       	ldi	r24, 0xB7	; 183
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
     47c:	3e c0       	rjmp	.+124    	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
			}
			else if(T>25)
     47e:	20 e0       	ldi	r18, 0x00	; 0
     480:	30 e0       	ldi	r19, 0x00	; 0
     482:	48 ec       	ldi	r20, 0xC8	; 200
     484:	51 e4       	ldi	r21, 0x41	; 65
     486:	c7 01       	movw	r24, r14
     488:	b6 01       	movw	r22, r12
     48a:	0e 94 92 10 	call	0x2124	; 0x2124 <__gesf2>
     48e:	18 16       	cp	r1, r24
     490:	dc f4       	brge	.+54     	; 0x4c8 <__EEPROM_REGION_LENGTH__+0xc8>
			{
				TIMER0_voidFastPWM(30)  ;
     492:	8e e1       	ldi	r24, 0x1E	; 30
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <TIMER0_voidFastPWM>
				
				LCD_voidGotoxy(7, 1);
     49a:	61 e0       	ldi	r22, 0x01	; 1
     49c:	87 e0       	ldi	r24, 0x07	; 7
     49e:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString(" FAN ");
     4a2:	81 eb       	ldi	r24, 0xB1	; 177
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				LCD_voidGotoxy(12, 1);
     4aa:	61 e0       	ldi	r22, 0x01	; 1
     4ac:	8c e0       	ldi	r24, 0x0C	; 12
     4ae:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendNumber(30);
     4b2:	6e e1       	ldi	r22, 0x1E	; 30
     4b4:	70 e0       	ldi	r23, 0x00	; 0
     4b6:	80 e0       	ldi	r24, 0x00	; 0
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_voidSendNumber>
				LCD_voidSendString("% ");
     4be:	87 eb       	ldi	r24, 0xB7	; 183
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
     4c6:	19 c0       	rjmp	.+50     	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
			}
			else
			{
				TIMER0_voidFastPWM(0)   ;
     4c8:	80 e0       	ldi	r24, 0x00	; 0
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <TIMER0_voidFastPWM>
				
				LCD_voidGotoxy(7, 1);
     4d0:	61 e0       	ldi	r22, 0x01	; 1
     4d2:	87 e0       	ldi	r24, 0x07	; 7
     4d4:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendString(" FAN ");
     4d8:	81 eb       	ldi	r24, 0xB1	; 177
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
				
				LCD_voidGotoxy(12, 1);
     4e0:	61 e0       	ldi	r22, 0x01	; 1
     4e2:	8c e0       	ldi	r24, 0x0C	; 12
     4e4:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
				LCD_voidSendNumber(0);
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	cb 01       	movw	r24, r22
     4ee:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <LCD_voidSendNumber>
				LCD_voidSendString("%  ");
     4f2:	8a eb       	ldi	r24, 0xBA	; 186
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
			}
		}
		xSemaphoreGive( LCD );
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	40 e0       	ldi	r20, 0x00	; 0
     4fe:	50 e0       	ldi	r21, 0x00	; 0
     500:	60 e0       	ldi	r22, 0x00	; 0
     502:	70 e0       	ldi	r23, 0x00	; 0
     504:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <LCD>
     508:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <LCD+0x1>
     50c:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
		vTaskDelay(100);
     510:	84 e6       	ldi	r24, 0x64	; 100
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	0e 94 9c 0b 	call	0x1738	; 0x1738 <vTaskDelay>
	}
     518:	46 cf       	rjmp	.-372    	; 0x3a6 <FAN+0x14>

0000051a <main>:
}

//-------------------------------------------------------------
//-------------------------------------------------------------
int main(void)
{
     51a:	ef 92       	push	r14
     51c:	ff 92       	push	r15
     51e:	0f 93       	push	r16
	//Directions
	DIO_voidSetPortDir(DIO_PORTA, 0xF0);
     520:	60 ef       	ldi	r22, 0xF0	; 240
     522:	80 e0       	ldi	r24, 0x00	; 0
     524:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <DIO_voidSetPortDir>
	DIO_voidSetPortDir(DIO_PORTB, 0xFF);
     528:	6f ef       	ldi	r22, 0xFF	; 255
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <DIO_voidSetPortDir>
	DIO_voidSetPortDir(DIO_PORTC, 0xFF);
     530:	6f ef       	ldi	r22, 0xFF	; 255
     532:	82 e0       	ldi	r24, 0x02	; 2
     534:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <DIO_voidSetPortDir>
	DIO_voidSetPortDir(DIO_PORTD, 0xF0);
     538:	60 ef       	ldi	r22, 0xF0	; 240
     53a:	83 e0       	ldi	r24, 0x03	; 3
     53c:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <DIO_voidSetPortDir>
	
	//Create Tasks
	xTaskCreate(LM35	, "LM35"    , 100, NULL, 6, NULL);
     540:	e1 2c       	mov	r14, r1
     542:	f1 2c       	mov	r15, r1
     544:	06 e0       	ldi	r16, 0x06	; 6
     546:	20 e0       	ldi	r18, 0x00	; 0
     548:	30 e0       	ldi	r19, 0x00	; 0
     54a:	44 e6       	ldi	r20, 0x64	; 100
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	6e eb       	ldi	r22, 0xBE	; 190
     550:	70 e0       	ldi	r23, 0x00	; 0
     552:	89 e4       	ldi	r24, 0x49	; 73
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
	xTaskCreate(Screen	, "Screen"  , 100, NULL, 5, NULL);
     55a:	05 e0       	ldi	r16, 0x05	; 5
     55c:	20 e0       	ldi	r18, 0x00	; 0
     55e:	30 e0       	ldi	r19, 0x00	; 0
     560:	44 e6       	ldi	r20, 0x64	; 100
     562:	50 e0       	ldi	r21, 0x00	; 0
     564:	63 ec       	ldi	r22, 0xC3	; 195
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	89 ef       	ldi	r24, 0xF9	; 249
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
	xTaskCreate(Terminal, "Terminal", 100, NULL, 7, NULL);
     570:	07 e0       	ldi	r16, 0x07	; 7
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	44 e6       	ldi	r20, 0x64	; 100
     578:	50 e0       	ldi	r21, 0x00	; 0
     57a:	6a ec       	ldi	r22, 0xCA	; 202
     57c:	70 e0       	ldi	r23, 0x00	; 0
     57e:	8c ea       	ldi	r24, 0xAC	; 172
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
	xTaskCreate(FAN		, "FAN"		, 100, NULL, 4, NULL);
     586:	04 e0       	ldi	r16, 0x04	; 4
     588:	20 e0       	ldi	r18, 0x00	; 0
     58a:	30 e0       	ldi	r19, 0x00	; 0
     58c:	44 e6       	ldi	r20, 0x64	; 100
     58e:	50 e0       	ldi	r21, 0x00	; 0
     590:	63 ed       	ldi	r22, 0xD3	; 211
     592:	70 e0       	ldi	r23, 0x00	; 0
     594:	89 ec       	ldi	r24, 0xC9	; 201
     596:	91 e0       	ldi	r25, 0x01	; 1
     598:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
	xTaskCreate(LDR		, "LDR"		, 100, NULL, 3, NULL);
     59c:	03 e0       	ldi	r16, 0x03	; 3
     59e:	20 e0       	ldi	r18, 0x00	; 0
     5a0:	30 e0       	ldi	r19, 0x00	; 0
     5a2:	44 e6       	ldi	r20, 0x64	; 100
     5a4:	50 e0       	ldi	r21, 0x00	; 0
     5a6:	67 ed       	ldi	r22, 0xD7	; 215
     5a8:	70 e0       	ldi	r23, 0x00	; 0
     5aa:	81 e5       	ldi	r24, 0x51	; 81
     5ac:	91 e0       	ldi	r25, 0x01	; 1
     5ae:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
	
	//Initialization of Peripherals
	GI_voidEnable();
     5b2:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <GI_voidEnable>
	UART_voidInit();
     5b6:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <UART_voidInit>
	LCD_voidInit();
     5ba:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <LCD_voidInit>
	ADC_voidInit();
     5be:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <ADC_voidInit>
	
	// Create Semaphore
	LCD = xSemaphoreCreateBinary();
     5c2:	43 e0       	ldi	r20, 0x03	; 3
     5c4:	60 e0       	ldi	r22, 0x00	; 0
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xQueueGenericCreate>
     5cc:	90 93 81 05 	sts	0x0581, r25	; 0x800581 <LCD+0x1>
     5d0:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <LCD>
	xSemaphoreGive(LCD);
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	40 e0       	ldi	r20, 0x00	; 0
     5d8:	50 e0       	ldi	r21, 0x00	; 0
     5da:	60 e0       	ldi	r22, 0x00	; 0
     5dc:	70 e0       	ldi	r23, 0x00	; 0
     5de:	0e 94 16 07 	call	0xe2c	; 0xe2c <xQueueGenericSend>
	
	// Create Queues
	Queue1 = xQueueCreate( 1, sizeof( f32 ) );
     5e2:	40 e0       	ldi	r20, 0x00	; 0
     5e4:	64 e0       	ldi	r22, 0x04	; 4
     5e6:	81 e0       	ldi	r24, 0x01	; 1
     5e8:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xQueueGenericCreate>
     5ec:	90 93 7f 05 	sts	0x057F, r25	; 0x80057f <Queue1+0x1>
     5f0:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <Queue1>
	Queue2 = xQueueCreate( 1, sizeof( u8  ) );
     5f4:	40 e0       	ldi	r20, 0x00	; 0
     5f6:	61 e0       	ldi	r22, 0x01	; 1
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xQueueGenericCreate>
     5fe:	90 93 79 05 	sts	0x0579, r25	; 0x800579 <Queue2+0x1>
     602:	80 93 78 05 	sts	0x0578, r24	; 0x800578 <Queue2>
	
	// Start Code
	LCD_voidGotoxy(0, 0);
     606:	60 e0       	ldi	r22, 0x00	; 0
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
	LCD_voidSendString("HELLO ABDULLAH");
     60e:	8b ed       	ldi	r24, 0xDB	; 219
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
	
	LCD_voidGotoxy(0, 1);
     616:	61 e0       	ldi	r22, 0x01	; 1
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <LCD_voidGotoxy>
	LCD_voidSendString("ENTER PASSWORD!");
     61e:	8a ee       	ldi	r24, 0xEA	; 234
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <LCD_voidSendString>
	
	// Start Scheduler
	vTaskStartScheduler();
     626:	0e 94 40 0a 	call	0x1480	; 0x1480 <vTaskStartScheduler>
}
     62a:	80 e0       	ldi	r24, 0x00	; 0
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	0f 91       	pop	r16
     630:	ff 90       	pop	r15
     632:	ef 90       	pop	r14
     634:	08 95       	ret

00000636 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     636:	e7 e0       	ldi	r30, 0x07	; 7
     638:	f1 e0       	ldi	r31, 0x01	; 1
     63a:	8c e0       	ldi	r24, 0x0C	; 12
     63c:	91 e0       	ldi	r25, 0x01	; 1
     63e:	91 83       	std	Z+1, r25	; 0x01
     640:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     642:	13 82       	std	Z+3, r1	; 0x03
     644:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     646:	e3 e0       	ldi	r30, 0x03	; 3
     648:	f1 e0       	ldi	r31, 0x01	; 1
     64a:	87 ee       	ldi	r24, 0xE7	; 231
     64c:	93 e0       	ldi	r25, 0x03	; 3
     64e:	93 83       	std	Z+3, r25	; 0x03
     650:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     652:	11 82       	std	Z+1, r1	; 0x01
     654:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     656:	ab e0       	ldi	r26, 0x0B	; 11
     658:	b1 e0       	ldi	r27, 0x01	; 1
     65a:	14 96       	adiw	r26, 0x04	; 4
     65c:	9c 93       	st	X, r25
     65e:	8e 93       	st	-X, r24
     660:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     662:	12 96       	adiw	r26, 0x02	; 2
     664:	fc 93       	st	X, r31
     666:	ee 93       	st	-X, r30
     668:	11 97       	sbiw	r26, 0x01	; 1
     66a:	08 95       	ret

0000066c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     66c:	0f 93       	push	r16
     66e:	1f 93       	push	r17
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     676:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     67a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xHeapHasBeenInitialised.2079>
     67e:	81 11       	cpse	r24, r1
     680:	05 c0       	rjmp	.+10     	; 0x68c <pvPortMalloc+0x20>
		{
			prvHeapInit();
     682:	0e 94 1b 03 	call	0x636	; 0x636 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     686:	81 e0       	ldi	r24, 0x01	; 1
     688:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     68c:	20 97       	sbiw	r28, 0x00	; 0
     68e:	09 f0       	breq	.+2      	; 0x692 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     690:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     692:	ce 01       	movw	r24, r28
     694:	01 97       	sbiw	r24, 0x01	; 1
     696:	86 3e       	cpi	r24, 0xE6	; 230
     698:	93 40       	sbci	r25, 0x03	; 3
     69a:	08 f0       	brcs	.+2      	; 0x69e <pvPortMalloc+0x32>
     69c:	56 c0       	rjmp	.+172    	; 0x74a <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     69e:	e0 91 07 01 	lds	r30, 0x0107	; 0x800107 <xStart>
     6a2:	f0 91 08 01 	lds	r31, 0x0108	; 0x800108 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     6a6:	a7 e0       	ldi	r26, 0x07	; 7
     6a8:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6aa:	02 c0       	rjmp	.+4      	; 0x6b0 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     6ac:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     6ae:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6b0:	82 81       	ldd	r24, Z+2	; 0x02
     6b2:	93 81       	ldd	r25, Z+3	; 0x03
     6b4:	8c 17       	cp	r24, r28
     6b6:	9d 07       	cpc	r25, r29
     6b8:	20 f4       	brcc	.+8      	; 0x6c2 <pvPortMalloc+0x56>
     6ba:	80 81       	ld	r24, Z
     6bc:	91 81       	ldd	r25, Z+1	; 0x01
     6be:	00 97       	sbiw	r24, 0x00	; 0
     6c0:	a9 f7       	brne	.-22     	; 0x6ac <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     6c2:	81 e0       	ldi	r24, 0x01	; 1
     6c4:	e3 30       	cpi	r30, 0x03	; 3
     6c6:	f8 07       	cpc	r31, r24
     6c8:	09 f4       	brne	.+2      	; 0x6cc <pvPortMalloc+0x60>
     6ca:	42 c0       	rjmp	.+132    	; 0x750 <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     6cc:	0d 91       	ld	r16, X+
     6ce:	1c 91       	ld	r17, X
     6d0:	11 97       	sbiw	r26, 0x01	; 1
     6d2:	0c 5f       	subi	r16, 0xFC	; 252
     6d4:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     6d6:	80 81       	ld	r24, Z
     6d8:	91 81       	ldd	r25, Z+1	; 0x01
     6da:	8d 93       	st	X+, r24
     6dc:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     6de:	82 81       	ldd	r24, Z+2	; 0x02
     6e0:	93 81       	ldd	r25, Z+3	; 0x03
     6e2:	8c 1b       	sub	r24, r28
     6e4:	9d 0b       	sbc	r25, r29
     6e6:	89 30       	cpi	r24, 0x09	; 9
     6e8:	91 05       	cpc	r25, r1
     6ea:	10 f1       	brcs	.+68     	; 0x730 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     6ec:	af 01       	movw	r20, r30
     6ee:	4c 0f       	add	r20, r28
     6f0:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     6f2:	da 01       	movw	r26, r20
     6f4:	13 96       	adiw	r26, 0x03	; 3
     6f6:	9c 93       	st	X, r25
     6f8:	8e 93       	st	-X, r24
     6fa:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     6fc:	d3 83       	std	Z+3, r29	; 0x03
     6fe:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     700:	12 96       	adiw	r26, 0x02	; 2
     702:	2d 91       	ld	r18, X+
     704:	3c 91       	ld	r19, X
     706:	13 97       	sbiw	r26, 0x03	; 3
     708:	67 e0       	ldi	r22, 0x07	; 7
     70a:	71 e0       	ldi	r23, 0x01	; 1
     70c:	01 c0       	rjmp	.+2      	; 0x710 <pvPortMalloc+0xa4>
     70e:	bd 01       	movw	r22, r26
     710:	eb 01       	movw	r28, r22
     712:	a8 81       	ld	r26, Y
     714:	b9 81       	ldd	r27, Y+1	; 0x01
     716:	12 96       	adiw	r26, 0x02	; 2
     718:	8d 91       	ld	r24, X+
     71a:	9c 91       	ld	r25, X
     71c:	13 97       	sbiw	r26, 0x03	; 3
     71e:	82 17       	cp	r24, r18
     720:	93 07       	cpc	r25, r19
     722:	a8 f3       	brcs	.-22     	; 0x70e <pvPortMalloc+0xa2>
     724:	ea 01       	movw	r28, r20
     726:	b9 83       	std	Y+1, r27	; 0x01
     728:	a8 83       	st	Y, r26
     72a:	db 01       	movw	r26, r22
     72c:	4d 93       	st	X+, r20
     72e:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     730:	22 81       	ldd	r18, Z+2	; 0x02
     732:	33 81       	ldd	r19, Z+3	; 0x03
     734:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <xFreeBytesRemaining>
     738:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <xFreeBytesRemaining+0x1>
     73c:	82 1b       	sub	r24, r18
     73e:	93 0b       	sbc	r25, r19
     740:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <xFreeBytesRemaining+0x1>
     744:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <xFreeBytesRemaining>
     748:	05 c0       	rjmp	.+10     	; 0x754 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     74a:	00 e0       	ldi	r16, 0x00	; 0
     74c:	10 e0       	ldi	r17, 0x00	; 0
     74e:	02 c0       	rjmp	.+4      	; 0x754 <pvPortMalloc+0xe8>
     750:	00 e0       	ldi	r16, 0x00	; 0
     752:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     754:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     758:	c8 01       	movw	r24, r16
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	1f 91       	pop	r17
     760:	0f 91       	pop	r16
     762:	08 95       	ret

00000764 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     764:	0f 93       	push	r16
     766:	1f 93       	push	r17
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     76c:	00 97       	sbiw	r24, 0x00	; 0
     76e:	41 f1       	breq	.+80     	; 0x7c0 <vPortFree+0x5c>
     770:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     772:	8c 01       	movw	r16, r24
     774:	04 50       	subi	r16, 0x04	; 4
     776:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     778:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     77c:	f8 01       	movw	r30, r16
     77e:	42 81       	ldd	r20, Z+2	; 0x02
     780:	53 81       	ldd	r21, Z+3	; 0x03
     782:	a7 e0       	ldi	r26, 0x07	; 7
     784:	b1 e0       	ldi	r27, 0x01	; 1
     786:	01 c0       	rjmp	.+2      	; 0x78a <vPortFree+0x26>
     788:	df 01       	movw	r26, r30
     78a:	ed 91       	ld	r30, X+
     78c:	fc 91       	ld	r31, X
     78e:	11 97       	sbiw	r26, 0x01	; 1
     790:	22 81       	ldd	r18, Z+2	; 0x02
     792:	33 81       	ldd	r19, Z+3	; 0x03
     794:	24 17       	cp	r18, r20
     796:	35 07       	cpc	r19, r21
     798:	b8 f3       	brcs	.-18     	; 0x788 <vPortFree+0x24>
     79a:	24 97       	sbiw	r28, 0x04	; 4
     79c:	f9 83       	std	Y+1, r31	; 0x01
     79e:	e8 83       	st	Y, r30
     7a0:	0d 93       	st	X+, r16
     7a2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     7a4:	8a 81       	ldd	r24, Y+2	; 0x02
     7a6:	9b 81       	ldd	r25, Y+3	; 0x03
     7a8:	20 91 64 00 	lds	r18, 0x0064	; 0x800064 <xFreeBytesRemaining>
     7ac:	30 91 65 00 	lds	r19, 0x0065	; 0x800065 <xFreeBytesRemaining+0x1>
     7b0:	82 0f       	add	r24, r18
     7b2:	93 1f       	adc	r25, r19
     7b4:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <xFreeBytesRemaining+0x1>
     7b8:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <xFreeBytesRemaining>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     7bc:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
	}
}
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	1f 91       	pop	r17
     7c6:	0f 91       	pop	r16
     7c8:	08 95       	ret

000007ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     7ca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7cc:	03 96       	adiw	r24, 0x03	; 3
     7ce:	92 83       	std	Z+2, r25	; 0x02
     7d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7d2:	2f ef       	ldi	r18, 0xFF	; 255
     7d4:	3f ef       	ldi	r19, 0xFF	; 255
     7d6:	34 83       	std	Z+4, r19	; 0x04
     7d8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7da:	96 83       	std	Z+6, r25	; 0x06
     7dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7de:	90 87       	std	Z+8, r25	; 0x08
     7e0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     7e2:	10 82       	st	Z, r1
     7e4:	08 95       	ret

000007e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     7e6:	fc 01       	movw	r30, r24
     7e8:	11 86       	std	Z+9, r1	; 0x09
     7ea:	10 86       	std	Z+8, r1	; 0x08
     7ec:	08 95       	ret

000007ee <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7ee:	cf 93       	push	r28
     7f0:	df 93       	push	r29
     7f2:	9c 01       	movw	r18, r24
     7f4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     7f6:	dc 01       	movw	r26, r24
     7f8:	11 96       	adiw	r26, 0x01	; 1
     7fa:	cd 91       	ld	r28, X+
     7fc:	dc 91       	ld	r29, X
     7fe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     800:	d3 83       	std	Z+3, r29	; 0x03
     802:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     804:	8c 81       	ldd	r24, Y+4	; 0x04
     806:	9d 81       	ldd	r25, Y+5	; 0x05
     808:	95 83       	std	Z+5, r25	; 0x05
     80a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     80c:	8c 81       	ldd	r24, Y+4	; 0x04
     80e:	9d 81       	ldd	r25, Y+5	; 0x05
     810:	dc 01       	movw	r26, r24
     812:	13 96       	adiw	r26, 0x03	; 3
     814:	7c 93       	st	X, r23
     816:	6e 93       	st	-X, r22
     818:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     81a:	7d 83       	std	Y+5, r23	; 0x05
     81c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     81e:	31 87       	std	Z+9, r19	; 0x09
     820:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     822:	f9 01       	movw	r30, r18
     824:	80 81       	ld	r24, Z
     826:	8f 5f       	subi	r24, 0xFF	; 255
     828:	80 83       	st	Z, r24
}
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	08 95       	ret

00000830 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     836:	48 81       	ld	r20, Y
     838:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     83a:	4f 3f       	cpi	r20, 0xFF	; 255
     83c:	2f ef       	ldi	r18, 0xFF	; 255
     83e:	52 07       	cpc	r21, r18
     840:	21 f4       	brne	.+8      	; 0x84a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     842:	fc 01       	movw	r30, r24
     844:	a7 81       	ldd	r26, Z+7	; 0x07
     846:	b0 85       	ldd	r27, Z+8	; 0x08
     848:	0d c0       	rjmp	.+26     	; 0x864 <__stack+0x5>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     84a:	dc 01       	movw	r26, r24
     84c:	13 96       	adiw	r26, 0x03	; 3
     84e:	01 c0       	rjmp	.+2      	; 0x852 <vListInsert+0x22>
     850:	df 01       	movw	r26, r30
     852:	12 96       	adiw	r26, 0x02	; 2
     854:	ed 91       	ld	r30, X+
     856:	fc 91       	ld	r31, X
     858:	13 97       	sbiw	r26, 0x03	; 3
     85a:	20 81       	ld	r18, Z
     85c:	31 81       	ldd	r19, Z+1	; 0x01
     85e:	42 17       	cp	r20, r18
     860:	53 07       	cpc	r21, r19
     862:	b0 f7       	brcc	.-20     	; 0x850 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     864:	12 96       	adiw	r26, 0x02	; 2
     866:	ed 91       	ld	r30, X+
     868:	fc 91       	ld	r31, X
     86a:	13 97       	sbiw	r26, 0x03	; 3
     86c:	fb 83       	std	Y+3, r31	; 0x03
     86e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     870:	d5 83       	std	Z+5, r29	; 0x05
     872:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     874:	bd 83       	std	Y+5, r27	; 0x05
     876:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     878:	13 96       	adiw	r26, 0x03	; 3
     87a:	dc 93       	st	X, r29
     87c:	ce 93       	st	-X, r28
     87e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     880:	99 87       	std	Y+9, r25	; 0x09
     882:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     884:	fc 01       	movw	r30, r24
     886:	20 81       	ld	r18, Z
     888:	2f 5f       	subi	r18, 0xFF	; 255
     88a:	20 83       	st	Z, r18
}
     88c:	df 91       	pop	r29
     88e:	cf 91       	pop	r28
     890:	08 95       	ret

00000892 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     892:	cf 93       	push	r28
     894:	df 93       	push	r29
     896:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     898:	a0 85       	ldd	r26, Z+8	; 0x08
     89a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     89c:	c2 81       	ldd	r28, Z+2	; 0x02
     89e:	d3 81       	ldd	r29, Z+3	; 0x03
     8a0:	84 81       	ldd	r24, Z+4	; 0x04
     8a2:	95 81       	ldd	r25, Z+5	; 0x05
     8a4:	9d 83       	std	Y+5, r25	; 0x05
     8a6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8a8:	c4 81       	ldd	r28, Z+4	; 0x04
     8aa:	d5 81       	ldd	r29, Z+5	; 0x05
     8ac:	82 81       	ldd	r24, Z+2	; 0x02
     8ae:	93 81       	ldd	r25, Z+3	; 0x03
     8b0:	9b 83       	std	Y+3, r25	; 0x03
     8b2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8b4:	11 96       	adiw	r26, 0x01	; 1
     8b6:	8d 91       	ld	r24, X+
     8b8:	9c 91       	ld	r25, X
     8ba:	12 97       	sbiw	r26, 0x02	; 2
     8bc:	e8 17       	cp	r30, r24
     8be:	f9 07       	cpc	r31, r25
     8c0:	31 f4       	brne	.+12     	; 0x8ce <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     8c2:	84 81       	ldd	r24, Z+4	; 0x04
     8c4:	95 81       	ldd	r25, Z+5	; 0x05
     8c6:	12 96       	adiw	r26, 0x02	; 2
     8c8:	9c 93       	st	X, r25
     8ca:	8e 93       	st	-X, r24
     8cc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     8ce:	11 86       	std	Z+9, r1	; 0x09
     8d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     8d2:	8c 91       	ld	r24, X
     8d4:	81 50       	subi	r24, 0x01	; 1
     8d6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     8de:	1b bc       	out	0x2b, r1	; 43
     8e0:	89 ef       	ldi	r24, 0xF9	; 249
     8e2:	8a bd       	out	0x2a, r24	; 42
     8e4:	8b e0       	ldi	r24, 0x0B	; 11
     8e6:	8e bd       	out	0x2e, r24	; 46
     8e8:	89 b7       	in	r24, 0x39	; 57
     8ea:	80 61       	ori	r24, 0x10	; 16
     8ec:	89 bf       	out	0x39, r24	; 57
     8ee:	08 95       	ret

000008f0 <pxPortInitialiseStack>:
     8f0:	31 e1       	ldi	r19, 0x11	; 17
     8f2:	fc 01       	movw	r30, r24
     8f4:	30 83       	st	Z, r19
     8f6:	31 97       	sbiw	r30, 0x01	; 1
     8f8:	22 e2       	ldi	r18, 0x22	; 34
     8fa:	20 83       	st	Z, r18
     8fc:	31 97       	sbiw	r30, 0x01	; 1
     8fe:	a3 e3       	ldi	r26, 0x33	; 51
     900:	a0 83       	st	Z, r26
     902:	31 97       	sbiw	r30, 0x01	; 1
     904:	60 83       	st	Z, r22
     906:	31 97       	sbiw	r30, 0x01	; 1
     908:	70 83       	st	Z, r23
     90a:	31 97       	sbiw	r30, 0x01	; 1
     90c:	10 82       	st	Z, r1
     90e:	31 97       	sbiw	r30, 0x01	; 1
     910:	60 e8       	ldi	r22, 0x80	; 128
     912:	60 83       	st	Z, r22
     914:	31 97       	sbiw	r30, 0x01	; 1
     916:	10 82       	st	Z, r1
     918:	31 97       	sbiw	r30, 0x01	; 1
     91a:	62 e0       	ldi	r22, 0x02	; 2
     91c:	60 83       	st	Z, r22
     91e:	31 97       	sbiw	r30, 0x01	; 1
     920:	63 e0       	ldi	r22, 0x03	; 3
     922:	60 83       	st	Z, r22
     924:	31 97       	sbiw	r30, 0x01	; 1
     926:	64 e0       	ldi	r22, 0x04	; 4
     928:	60 83       	st	Z, r22
     92a:	31 97       	sbiw	r30, 0x01	; 1
     92c:	65 e0       	ldi	r22, 0x05	; 5
     92e:	60 83       	st	Z, r22
     930:	31 97       	sbiw	r30, 0x01	; 1
     932:	66 e0       	ldi	r22, 0x06	; 6
     934:	60 83       	st	Z, r22
     936:	31 97       	sbiw	r30, 0x01	; 1
     938:	67 e0       	ldi	r22, 0x07	; 7
     93a:	60 83       	st	Z, r22
     93c:	31 97       	sbiw	r30, 0x01	; 1
     93e:	68 e0       	ldi	r22, 0x08	; 8
     940:	60 83       	st	Z, r22
     942:	31 97       	sbiw	r30, 0x01	; 1
     944:	69 e0       	ldi	r22, 0x09	; 9
     946:	60 83       	st	Z, r22
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	60 e1       	ldi	r22, 0x10	; 16
     94c:	60 83       	st	Z, r22
     94e:	31 97       	sbiw	r30, 0x01	; 1
     950:	30 83       	st	Z, r19
     952:	31 97       	sbiw	r30, 0x01	; 1
     954:	32 e1       	ldi	r19, 0x12	; 18
     956:	30 83       	st	Z, r19
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	33 e1       	ldi	r19, 0x13	; 19
     95c:	30 83       	st	Z, r19
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	34 e1       	ldi	r19, 0x14	; 20
     962:	30 83       	st	Z, r19
     964:	31 97       	sbiw	r30, 0x01	; 1
     966:	35 e1       	ldi	r19, 0x15	; 21
     968:	30 83       	st	Z, r19
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	36 e1       	ldi	r19, 0x16	; 22
     96e:	30 83       	st	Z, r19
     970:	31 97       	sbiw	r30, 0x01	; 1
     972:	37 e1       	ldi	r19, 0x17	; 23
     974:	30 83       	st	Z, r19
     976:	31 97       	sbiw	r30, 0x01	; 1
     978:	38 e1       	ldi	r19, 0x18	; 24
     97a:	30 83       	st	Z, r19
     97c:	31 97       	sbiw	r30, 0x01	; 1
     97e:	39 e1       	ldi	r19, 0x19	; 25
     980:	30 83       	st	Z, r19
     982:	31 97       	sbiw	r30, 0x01	; 1
     984:	30 e2       	ldi	r19, 0x20	; 32
     986:	30 83       	st	Z, r19
     988:	31 97       	sbiw	r30, 0x01	; 1
     98a:	31 e2       	ldi	r19, 0x21	; 33
     98c:	30 83       	st	Z, r19
     98e:	31 97       	sbiw	r30, 0x01	; 1
     990:	20 83       	st	Z, r18
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	23 e2       	ldi	r18, 0x23	; 35
     996:	20 83       	st	Z, r18
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	40 83       	st	Z, r20
     99c:	31 97       	sbiw	r30, 0x01	; 1
     99e:	50 83       	st	Z, r21
     9a0:	31 97       	sbiw	r30, 0x01	; 1
     9a2:	26 e2       	ldi	r18, 0x26	; 38
     9a4:	20 83       	st	Z, r18
     9a6:	31 97       	sbiw	r30, 0x01	; 1
     9a8:	27 e2       	ldi	r18, 0x27	; 39
     9aa:	20 83       	st	Z, r18
     9ac:	31 97       	sbiw	r30, 0x01	; 1
     9ae:	28 e2       	ldi	r18, 0x28	; 40
     9b0:	20 83       	st	Z, r18
     9b2:	31 97       	sbiw	r30, 0x01	; 1
     9b4:	29 e2       	ldi	r18, 0x29	; 41
     9b6:	20 83       	st	Z, r18
     9b8:	31 97       	sbiw	r30, 0x01	; 1
     9ba:	20 e3       	ldi	r18, 0x30	; 48
     9bc:	20 83       	st	Z, r18
     9be:	31 97       	sbiw	r30, 0x01	; 1
     9c0:	21 e3       	ldi	r18, 0x31	; 49
     9c2:	20 83       	st	Z, r18
     9c4:	86 97       	sbiw	r24, 0x26	; 38
     9c6:	08 95       	ret

000009c8 <xPortStartScheduler>:
     9c8:	0e 94 6f 04 	call	0x8de	; 0x8de <prvSetupTimerInterrupt>
     9cc:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
     9d0:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
     9d4:	cd 91       	ld	r28, X+
     9d6:	cd bf       	out	0x3d, r28	; 61
     9d8:	dd 91       	ld	r29, X+
     9da:	de bf       	out	0x3e, r29	; 62
     9dc:	ff 91       	pop	r31
     9de:	ef 91       	pop	r30
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	bf 91       	pop	r27
     9e6:	af 91       	pop	r26
     9e8:	9f 91       	pop	r25
     9ea:	8f 91       	pop	r24
     9ec:	7f 91       	pop	r23
     9ee:	6f 91       	pop	r22
     9f0:	5f 91       	pop	r21
     9f2:	4f 91       	pop	r20
     9f4:	3f 91       	pop	r19
     9f6:	2f 91       	pop	r18
     9f8:	1f 91       	pop	r17
     9fa:	0f 91       	pop	r16
     9fc:	ff 90       	pop	r15
     9fe:	ef 90       	pop	r14
     a00:	df 90       	pop	r13
     a02:	cf 90       	pop	r12
     a04:	bf 90       	pop	r11
     a06:	af 90       	pop	r10
     a08:	9f 90       	pop	r9
     a0a:	8f 90       	pop	r8
     a0c:	7f 90       	pop	r7
     a0e:	6f 90       	pop	r6
     a10:	5f 90       	pop	r5
     a12:	4f 90       	pop	r4
     a14:	3f 90       	pop	r3
     a16:	2f 90       	pop	r2
     a18:	1f 90       	pop	r1
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0
     a20:	08 95       	ret
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	08 95       	ret

00000a26 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a26:	0f 92       	push	r0
     a28:	0f b6       	in	r0, 0x3f	; 63
     a2a:	f8 94       	cli
     a2c:	0f 92       	push	r0
     a2e:	1f 92       	push	r1
     a30:	11 24       	eor	r1, r1
     a32:	2f 92       	push	r2
     a34:	3f 92       	push	r3
     a36:	4f 92       	push	r4
     a38:	5f 92       	push	r5
     a3a:	6f 92       	push	r6
     a3c:	7f 92       	push	r7
     a3e:	8f 92       	push	r8
     a40:	9f 92       	push	r9
     a42:	af 92       	push	r10
     a44:	bf 92       	push	r11
     a46:	cf 92       	push	r12
     a48:	df 92       	push	r13
     a4a:	ef 92       	push	r14
     a4c:	ff 92       	push	r15
     a4e:	0f 93       	push	r16
     a50:	1f 93       	push	r17
     a52:	2f 93       	push	r18
     a54:	3f 93       	push	r19
     a56:	4f 93       	push	r20
     a58:	5f 93       	push	r21
     a5a:	6f 93       	push	r22
     a5c:	7f 93       	push	r23
     a5e:	8f 93       	push	r24
     a60:	9f 93       	push	r25
     a62:	af 93       	push	r26
     a64:	bf 93       	push	r27
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ef 93       	push	r30
     a6c:	ff 93       	push	r31
     a6e:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
     a72:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
     a76:	0d b6       	in	r0, 0x3d	; 61
     a78:	0d 92       	st	X+, r0
     a7a:	0e b6       	in	r0, 0x3e	; 62
     a7c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     a7e:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     a82:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
     a86:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
     a8a:	cd 91       	ld	r28, X+
     a8c:	cd bf       	out	0x3d, r28	; 61
     a8e:	dd 91       	ld	r29, X+
     a90:	de bf       	out	0x3e, r29	; 62
     a92:	ff 91       	pop	r31
     a94:	ef 91       	pop	r30
     a96:	df 91       	pop	r29
     a98:	cf 91       	pop	r28
     a9a:	bf 91       	pop	r27
     a9c:	af 91       	pop	r26
     a9e:	9f 91       	pop	r25
     aa0:	8f 91       	pop	r24
     aa2:	7f 91       	pop	r23
     aa4:	6f 91       	pop	r22
     aa6:	5f 91       	pop	r21
     aa8:	4f 91       	pop	r20
     aaa:	3f 91       	pop	r19
     aac:	2f 91       	pop	r18
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	cf 90       	pop	r12
     aba:	bf 90       	pop	r11
     abc:	af 90       	pop	r10
     abe:	9f 90       	pop	r9
     ac0:	8f 90       	pop	r8
     ac2:	7f 90       	pop	r7
     ac4:	6f 90       	pop	r6
     ac6:	5f 90       	pop	r5
     ac8:	4f 90       	pop	r4
     aca:	3f 90       	pop	r3
     acc:	2f 90       	pop	r2
     ace:	1f 90       	pop	r1
     ad0:	0f 90       	pop	r0
     ad2:	0f be       	out	0x3f, r0	; 63
     ad4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ad6:	08 95       	ret

00000ad8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ad8:	0f 92       	push	r0
     ada:	0f b6       	in	r0, 0x3f	; 63
     adc:	f8 94       	cli
     ade:	0f 92       	push	r0
     ae0:	1f 92       	push	r1
     ae2:	11 24       	eor	r1, r1
     ae4:	2f 92       	push	r2
     ae6:	3f 92       	push	r3
     ae8:	4f 92       	push	r4
     aea:	5f 92       	push	r5
     aec:	6f 92       	push	r6
     aee:	7f 92       	push	r7
     af0:	8f 92       	push	r8
     af2:	9f 92       	push	r9
     af4:	af 92       	push	r10
     af6:	bf 92       	push	r11
     af8:	cf 92       	push	r12
     afa:	df 92       	push	r13
     afc:	ef 92       	push	r14
     afe:	ff 92       	push	r15
     b00:	0f 93       	push	r16
     b02:	1f 93       	push	r17
     b04:	2f 93       	push	r18
     b06:	3f 93       	push	r19
     b08:	4f 93       	push	r20
     b0a:	5f 93       	push	r21
     b0c:	6f 93       	push	r22
     b0e:	7f 93       	push	r23
     b10:	8f 93       	push	r24
     b12:	9f 93       	push	r25
     b14:	af 93       	push	r26
     b16:	bf 93       	push	r27
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29
     b1c:	ef 93       	push	r30
     b1e:	ff 93       	push	r31
     b20:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
     b24:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
     b28:	0d b6       	in	r0, 0x3d	; 61
     b2a:	0d 92       	st	X+, r0
     b2c:	0e b6       	in	r0, 0x3e	; 62
     b2e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b30:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <xTaskIncrementTick>
     b34:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b36:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b3a:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
     b3e:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
     b42:	cd 91       	ld	r28, X+
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	dd 91       	ld	r29, X+
     b48:	de bf       	out	0x3e, r29	; 62
     b4a:	ff 91       	pop	r31
     b4c:	ef 91       	pop	r30
     b4e:	df 91       	pop	r29
     b50:	cf 91       	pop	r28
     b52:	bf 91       	pop	r27
     b54:	af 91       	pop	r26
     b56:	9f 91       	pop	r25
     b58:	8f 91       	pop	r24
     b5a:	7f 91       	pop	r23
     b5c:	6f 91       	pop	r22
     b5e:	5f 91       	pop	r21
     b60:	4f 91       	pop	r20
     b62:	3f 91       	pop	r19
     b64:	2f 91       	pop	r18
     b66:	1f 91       	pop	r17
     b68:	0f 91       	pop	r16
     b6a:	ff 90       	pop	r15
     b6c:	ef 90       	pop	r14
     b6e:	df 90       	pop	r13
     b70:	cf 90       	pop	r12
     b72:	bf 90       	pop	r11
     b74:	af 90       	pop	r10
     b76:	9f 90       	pop	r9
     b78:	8f 90       	pop	r8
     b7a:	7f 90       	pop	r7
     b7c:	6f 90       	pop	r6
     b7e:	5f 90       	pop	r5
     b80:	4f 90       	pop	r4
     b82:	3f 90       	pop	r3
     b84:	2f 90       	pop	r2
     b86:	1f 90       	pop	r1
     b88:	0f 90       	pop	r0
     b8a:	0f be       	out	0x3f, r0	; 63
     b8c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b8e:	08 95       	ret

00000b90 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     b90:	0e 94 6c 05 	call	0xad8	; 0xad8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     b94:	18 95       	reti

00000b96 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     b96:	0f b6       	in	r0, 0x3f	; 63
     b98:	f8 94       	cli
     b9a:	0f 92       	push	r0
     b9c:	fc 01       	movw	r30, r24
     b9e:	82 8d       	ldd	r24, Z+26	; 0x1a
     ba0:	81 11       	cpse	r24, r1
     ba2:	02 c0       	rjmp	.+4      	; 0xba8 <prvIsQueueEmpty+0x12>
     ba4:	81 e0       	ldi	r24, 0x01	; 1
     ba6:	01 c0       	rjmp	.+2      	; 0xbaa <prvIsQueueEmpty+0x14>
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	08 95       	ret

00000bb0 <prvIsQueueFull>:
     bb0:	0f b6       	in	r0, 0x3f	; 63
     bb2:	f8 94       	cli
     bb4:	0f 92       	push	r0
     bb6:	fc 01       	movw	r30, r24
     bb8:	22 8d       	ldd	r18, Z+26	; 0x1a
     bba:	83 8d       	ldd	r24, Z+27	; 0x1b
     bbc:	28 13       	cpse	r18, r24
     bbe:	02 c0       	rjmp	.+4      	; 0xbc4 <prvIsQueueFull+0x14>
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	01 c0       	rjmp	.+2      	; 0xbc6 <prvIsQueueFull+0x16>
     bc4:	80 e0       	ldi	r24, 0x00	; 0
     bc6:	0f 90       	pop	r0
     bc8:	0f be       	out	0x3f, r0	; 63
     bca:	08 95       	ret

00000bcc <prvCopyDataToQueue>:
     bcc:	0f 93       	push	r16
     bce:	1f 93       	push	r17
     bd0:	cf 93       	push	r28
     bd2:	df 93       	push	r29
     bd4:	ec 01       	movw	r28, r24
     bd6:	04 2f       	mov	r16, r20
     bd8:	1a 8d       	ldd	r17, Y+26	; 0x1a
     bda:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bdc:	41 11       	cpse	r20, r1
     bde:	0c c0       	rjmp	.+24     	; 0xbf8 <prvCopyDataToQueue+0x2c>
     be0:	88 81       	ld	r24, Y
     be2:	99 81       	ldd	r25, Y+1	; 0x01
     be4:	89 2b       	or	r24, r25
     be6:	09 f0       	breq	.+2      	; 0xbea <prvCopyDataToQueue+0x1e>
     be8:	42 c0       	rjmp	.+132    	; 0xc6e <prvCopyDataToQueue+0xa2>
     bea:	8a 81       	ldd	r24, Y+2	; 0x02
     bec:	9b 81       	ldd	r25, Y+3	; 0x03
     bee:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <xTaskPriorityDisinherit>
     bf2:	1b 82       	std	Y+3, r1	; 0x03
     bf4:	1a 82       	std	Y+2, r1	; 0x02
     bf6:	42 c0       	rjmp	.+132    	; 0xc7c <prvCopyDataToQueue+0xb0>
     bf8:	01 11       	cpse	r16, r1
     bfa:	17 c0       	rjmp	.+46     	; 0xc2a <prvCopyDataToQueue+0x5e>
     bfc:	50 e0       	ldi	r21, 0x00	; 0
     bfe:	8c 81       	ldd	r24, Y+4	; 0x04
     c00:	9d 81       	ldd	r25, Y+5	; 0x05
     c02:	0e 94 93 11 	call	0x2326	; 0x2326 <memcpy>
     c06:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c08:	8c 81       	ldd	r24, Y+4	; 0x04
     c0a:	9d 81       	ldd	r25, Y+5	; 0x05
     c0c:	82 0f       	add	r24, r18
     c0e:	91 1d       	adc	r25, r1
     c10:	9d 83       	std	Y+5, r25	; 0x05
     c12:	8c 83       	std	Y+4, r24	; 0x04
     c14:	2a 81       	ldd	r18, Y+2	; 0x02
     c16:	3b 81       	ldd	r19, Y+3	; 0x03
     c18:	82 17       	cp	r24, r18
     c1a:	93 07       	cpc	r25, r19
     c1c:	50 f1       	brcs	.+84     	; 0xc72 <prvCopyDataToQueue+0xa6>
     c1e:	88 81       	ld	r24, Y
     c20:	99 81       	ldd	r25, Y+1	; 0x01
     c22:	9d 83       	std	Y+5, r25	; 0x05
     c24:	8c 83       	std	Y+4, r24	; 0x04
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	29 c0       	rjmp	.+82     	; 0xc7c <prvCopyDataToQueue+0xb0>
     c2a:	50 e0       	ldi	r21, 0x00	; 0
     c2c:	8e 81       	ldd	r24, Y+6	; 0x06
     c2e:	9f 81       	ldd	r25, Y+7	; 0x07
     c30:	0e 94 93 11 	call	0x2326	; 0x2326 <memcpy>
     c34:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	91 95       	neg	r25
     c3a:	81 95       	neg	r24
     c3c:	91 09       	sbc	r25, r1
     c3e:	2e 81       	ldd	r18, Y+6	; 0x06
     c40:	3f 81       	ldd	r19, Y+7	; 0x07
     c42:	28 0f       	add	r18, r24
     c44:	39 1f       	adc	r19, r25
     c46:	3f 83       	std	Y+7, r19	; 0x07
     c48:	2e 83       	std	Y+6, r18	; 0x06
     c4a:	48 81       	ld	r20, Y
     c4c:	59 81       	ldd	r21, Y+1	; 0x01
     c4e:	24 17       	cp	r18, r20
     c50:	35 07       	cpc	r19, r21
     c52:	30 f4       	brcc	.+12     	; 0xc60 <prvCopyDataToQueue+0x94>
     c54:	2a 81       	ldd	r18, Y+2	; 0x02
     c56:	3b 81       	ldd	r19, Y+3	; 0x03
     c58:	82 0f       	add	r24, r18
     c5a:	93 1f       	adc	r25, r19
     c5c:	9f 83       	std	Y+7, r25	; 0x07
     c5e:	8e 83       	std	Y+6, r24	; 0x06
     c60:	02 30       	cpi	r16, 0x02	; 2
     c62:	49 f4       	brne	.+18     	; 0xc76 <prvCopyDataToQueue+0xaa>
     c64:	11 23       	and	r17, r17
     c66:	49 f0       	breq	.+18     	; 0xc7a <prvCopyDataToQueue+0xae>
     c68:	11 50       	subi	r17, 0x01	; 1
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	07 c0       	rjmp	.+14     	; 0xc7c <prvCopyDataToQueue+0xb0>
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	05 c0       	rjmp	.+10     	; 0xc7c <prvCopyDataToQueue+0xb0>
     c72:	80 e0       	ldi	r24, 0x00	; 0
     c74:	03 c0       	rjmp	.+6      	; 0xc7c <prvCopyDataToQueue+0xb0>
     c76:	80 e0       	ldi	r24, 0x00	; 0
     c78:	01 c0       	rjmp	.+2      	; 0xc7c <prvCopyDataToQueue+0xb0>
     c7a:	80 e0       	ldi	r24, 0x00	; 0
     c7c:	1f 5f       	subi	r17, 0xFF	; 255
     c7e:	1a 8f       	std	Y+26, r17	; 0x1a
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	1f 91       	pop	r17
     c86:	0f 91       	pop	r16
     c88:	08 95       	ret

00000c8a <prvCopyDataFromQueue>:
     c8a:	fc 01       	movw	r30, r24
     c8c:	44 8d       	ldd	r20, Z+28	; 0x1c
     c8e:	44 23       	and	r20, r20
     c90:	a9 f0       	breq	.+42     	; 0xcbc <prvCopyDataFromQueue+0x32>
     c92:	50 e0       	ldi	r21, 0x00	; 0
     c94:	26 81       	ldd	r18, Z+6	; 0x06
     c96:	37 81       	ldd	r19, Z+7	; 0x07
     c98:	24 0f       	add	r18, r20
     c9a:	35 1f       	adc	r19, r21
     c9c:	37 83       	std	Z+7, r19	; 0x07
     c9e:	26 83       	std	Z+6, r18	; 0x06
     ca0:	82 81       	ldd	r24, Z+2	; 0x02
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	28 17       	cp	r18, r24
     ca6:	39 07       	cpc	r19, r25
     ca8:	20 f0       	brcs	.+8      	; 0xcb2 <prvCopyDataFromQueue+0x28>
     caa:	80 81       	ld	r24, Z
     cac:	91 81       	ldd	r25, Z+1	; 0x01
     cae:	97 83       	std	Z+7, r25	; 0x07
     cb0:	86 83       	std	Z+6, r24	; 0x06
     cb2:	cb 01       	movw	r24, r22
     cb4:	66 81       	ldd	r22, Z+6	; 0x06
     cb6:	77 81       	ldd	r23, Z+7	; 0x07
     cb8:	0e 94 93 11 	call	0x2326	; 0x2326 <memcpy>
     cbc:	08 95       	ret

00000cbe <prvUnlockQueue>:
     cbe:	1f 93       	push	r17
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	ec 01       	movw	r28, r24
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	0f 92       	push	r0
     ccc:	1e 8d       	ldd	r17, Y+30	; 0x1e
     cce:	0b c0       	rjmp	.+22     	; 0xce6 <prvUnlockQueue+0x28>
     cd0:	89 89       	ldd	r24, Y+17	; 0x11
     cd2:	88 23       	and	r24, r24
     cd4:	51 f0       	breq	.+20     	; 0xcea <prvUnlockQueue+0x2c>
     cd6:	ce 01       	movw	r24, r28
     cd8:	41 96       	adiw	r24, 0x11	; 17
     cda:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     cde:	81 11       	cpse	r24, r1
     ce0:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <vTaskMissedYield>
     ce4:	11 50       	subi	r17, 0x01	; 1
     ce6:	11 16       	cp	r1, r17
     ce8:	9c f3       	brlt	.-26     	; 0xcd0 <prvUnlockQueue+0x12>
     cea:	8f ef       	ldi	r24, 0xFF	; 255
     cec:	8e 8f       	std	Y+30, r24	; 0x1e
     cee:	0f 90       	pop	r0
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	0f b6       	in	r0, 0x3f	; 63
     cf4:	f8 94       	cli
     cf6:	0f 92       	push	r0
     cf8:	1d 8d       	ldd	r17, Y+29	; 0x1d
     cfa:	0b c0       	rjmp	.+22     	; 0xd12 <prvUnlockQueue+0x54>
     cfc:	88 85       	ldd	r24, Y+8	; 0x08
     cfe:	88 23       	and	r24, r24
     d00:	51 f0       	breq	.+20     	; 0xd16 <prvUnlockQueue+0x58>
     d02:	ce 01       	movw	r24, r28
     d04:	08 96       	adiw	r24, 0x08	; 8
     d06:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     d0a:	81 11       	cpse	r24, r1
     d0c:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <vTaskMissedYield>
     d10:	11 50       	subi	r17, 0x01	; 1
     d12:	11 16       	cp	r1, r17
     d14:	9c f3       	brlt	.-26     	; 0xcfc <prvUnlockQueue+0x3e>
     d16:	8f ef       	ldi	r24, 0xFF	; 255
     d18:	8d 8f       	std	Y+29, r24	; 0x1d
     d1a:	0f 90       	pop	r0
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	1f 91       	pop	r17
     d24:	08 95       	ret

00000d26 <xQueueGenericReset>:
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	ec 01       	movw	r28, r24
     d2c:	0f b6       	in	r0, 0x3f	; 63
     d2e:	f8 94       	cli
     d30:	0f 92       	push	r0
     d32:	e8 81       	ld	r30, Y
     d34:	f9 81       	ldd	r31, Y+1	; 0x01
     d36:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d3c:	30 e0       	ldi	r19, 0x00	; 0
     d3e:	82 9f       	mul	r24, r18
     d40:	a0 01       	movw	r20, r0
     d42:	83 9f       	mul	r24, r19
     d44:	50 0d       	add	r21, r0
     d46:	92 9f       	mul	r25, r18
     d48:	50 0d       	add	r21, r0
     d4a:	11 24       	eor	r1, r1
     d4c:	4e 0f       	add	r20, r30
     d4e:	5f 1f       	adc	r21, r31
     d50:	5b 83       	std	Y+3, r21	; 0x03
     d52:	4a 83       	std	Y+2, r20	; 0x02
     d54:	1a 8e       	std	Y+26, r1	; 0x1a
     d56:	fd 83       	std	Y+5, r31	; 0x05
     d58:	ec 83       	std	Y+4, r30	; 0x04
     d5a:	01 97       	sbiw	r24, 0x01	; 1
     d5c:	28 9f       	mul	r18, r24
     d5e:	a0 01       	movw	r20, r0
     d60:	29 9f       	mul	r18, r25
     d62:	50 0d       	add	r21, r0
     d64:	38 9f       	mul	r19, r24
     d66:	50 0d       	add	r21, r0
     d68:	11 24       	eor	r1, r1
     d6a:	cf 01       	movw	r24, r30
     d6c:	84 0f       	add	r24, r20
     d6e:	95 1f       	adc	r25, r21
     d70:	9f 83       	std	Y+7, r25	; 0x07
     d72:	8e 83       	std	Y+6, r24	; 0x06
     d74:	8f ef       	ldi	r24, 0xFF	; 255
     d76:	8d 8f       	std	Y+29, r24	; 0x1d
     d78:	8e 8f       	std	Y+30, r24	; 0x1e
     d7a:	61 11       	cpse	r22, r1
     d7c:	0c c0       	rjmp	.+24     	; 0xd96 <xQueueGenericReset+0x70>
     d7e:	88 85       	ldd	r24, Y+8	; 0x08
     d80:	88 23       	and	r24, r24
     d82:	89 f0       	breq	.+34     	; 0xda6 <xQueueGenericReset+0x80>
     d84:	ce 01       	movw	r24, r28
     d86:	08 96       	adiw	r24, 0x08	; 8
     d88:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     d8c:	88 23       	and	r24, r24
     d8e:	59 f0       	breq	.+22     	; 0xda6 <xQueueGenericReset+0x80>
     d90:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
     d94:	08 c0       	rjmp	.+16     	; 0xda6 <xQueueGenericReset+0x80>
     d96:	ce 01       	movw	r24, r28
     d98:	08 96       	adiw	r24, 0x08	; 8
     d9a:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
     d9e:	ce 01       	movw	r24, r28
     da0:	41 96       	adiw	r24, 0x11	; 17
     da2:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
     da6:	0f 90       	pop	r0
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	df 91       	pop	r29
     dae:	cf 91       	pop	r28
     db0:	08 95       	ret

00000db2 <prvInitialiseNewQueue>:
     db2:	0f 93       	push	r16
     db4:	1f 93       	push	r17
     db6:	f8 01       	movw	r30, r16
     db8:	61 11       	cpse	r22, r1
     dba:	03 c0       	rjmp	.+6      	; 0xdc2 <prvInitialiseNewQueue+0x10>
     dbc:	11 83       	std	Z+1, r17	; 0x01
     dbe:	00 83       	st	Z, r16
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <prvInitialiseNewQueue+0x14>
     dc2:	51 83       	std	Z+1, r21	; 0x01
     dc4:	40 83       	st	Z, r20
     dc6:	83 8f       	std	Z+27, r24	; 0x1b
     dc8:	64 8f       	std	Z+28, r22	; 0x1c
     dca:	61 e0       	ldi	r22, 0x01	; 1
     dcc:	cf 01       	movw	r24, r30
     dce:	0e 94 93 06 	call	0xd26	; 0xd26 <xQueueGenericReset>
     dd2:	1f 91       	pop	r17
     dd4:	0f 91       	pop	r16
     dd6:	08 95       	ret

00000dd8 <xQueueGenericCreate>:
     dd8:	df 92       	push	r13
     dda:	ef 92       	push	r14
     ddc:	ff 92       	push	r15
     dde:	0f 93       	push	r16
     de0:	1f 93       	push	r17
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	e8 2e       	mov	r14, r24
     de8:	f6 2e       	mov	r15, r22
     dea:	d4 2e       	mov	r13, r20
     dec:	66 23       	and	r22, r22
     dee:	21 f0       	breq	.+8      	; 0xdf8 <xQueueGenericCreate+0x20>
     df0:	86 9f       	mul	r24, r22
     df2:	c0 01       	movw	r24, r0
     df4:	11 24       	eor	r1, r1
     df6:	02 c0       	rjmp	.+4      	; 0xdfc <xQueueGenericCreate+0x24>
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	4f 96       	adiw	r24, 0x1f	; 31
     dfe:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
     e02:	ec 01       	movw	r28, r24
     e04:	00 97       	sbiw	r24, 0x00	; 0
     e06:	49 f0       	breq	.+18     	; 0xe1a <xQueueGenericCreate+0x42>
     e08:	8c 01       	movw	r16, r24
     e0a:	2d 2d       	mov	r18, r13
     e0c:	ac 01       	movw	r20, r24
     e0e:	41 5e       	subi	r20, 0xE1	; 225
     e10:	5f 4f       	sbci	r21, 0xFF	; 255
     e12:	6f 2d       	mov	r22, r15
     e14:	8e 2d       	mov	r24, r14
     e16:	0e 94 d9 06 	call	0xdb2	; 0xdb2 <prvInitialiseNewQueue>
     e1a:	ce 01       	movw	r24, r28
     e1c:	df 91       	pop	r29
     e1e:	cf 91       	pop	r28
     e20:	1f 91       	pop	r17
     e22:	0f 91       	pop	r16
     e24:	ff 90       	pop	r15
     e26:	ef 90       	pop	r14
     e28:	df 90       	pop	r13
     e2a:	08 95       	ret

00000e2c <xQueueGenericSend>:
     e2c:	cf 92       	push	r12
     e2e:	df 92       	push	r13
     e30:	ef 92       	push	r14
     e32:	ff 92       	push	r15
     e34:	0f 93       	push	r16
     e36:	1f 93       	push	r17
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	00 d0       	rcall	.+0      	; 0xe3e <xQueueGenericSend+0x12>
     e3e:	00 d0       	rcall	.+0      	; 0xe40 <xQueueGenericSend+0x14>
     e40:	1f 92       	push	r1
     e42:	cd b7       	in	r28, 0x3d	; 61
     e44:	de b7       	in	r29, 0x3e	; 62
     e46:	8c 01       	movw	r16, r24
     e48:	7b 01       	movw	r14, r22
     e4a:	5d 83       	std	Y+5, r21	; 0x05
     e4c:	4c 83       	std	Y+4, r20	; 0x04
     e4e:	c2 2e       	mov	r12, r18
     e50:	d1 2c       	mov	r13, r1
     e52:	0f b6       	in	r0, 0x3f	; 63
     e54:	f8 94       	cli
     e56:	0f 92       	push	r0
     e58:	f8 01       	movw	r30, r16
     e5a:	92 8d       	ldd	r25, Z+26	; 0x1a
     e5c:	83 8d       	ldd	r24, Z+27	; 0x1b
     e5e:	98 17       	cp	r25, r24
     e60:	18 f0       	brcs	.+6      	; 0xe68 <xQueueGenericSend+0x3c>
     e62:	f2 e0       	ldi	r31, 0x02	; 2
     e64:	cf 12       	cpse	r12, r31
     e66:	19 c0       	rjmp	.+50     	; 0xe9a <xQueueGenericSend+0x6e>
     e68:	4c 2d       	mov	r20, r12
     e6a:	b7 01       	movw	r22, r14
     e6c:	c8 01       	movw	r24, r16
     e6e:	0e 94 e6 05 	call	0xbcc	; 0xbcc <prvCopyDataToQueue>
     e72:	f8 01       	movw	r30, r16
     e74:	91 89       	ldd	r25, Z+17	; 0x11
     e76:	99 23       	and	r25, r25
     e78:	49 f0       	breq	.+18     	; 0xe8c <xQueueGenericSend+0x60>
     e7a:	c8 01       	movw	r24, r16
     e7c:	41 96       	adiw	r24, 0x11	; 17
     e7e:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     e82:	88 23       	and	r24, r24
     e84:	31 f0       	breq	.+12     	; 0xe92 <xQueueGenericSend+0x66>
     e86:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
     e8a:	03 c0       	rjmp	.+6      	; 0xe92 <xQueueGenericSend+0x66>
     e8c:	81 11       	cpse	r24, r1
     e8e:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
     e92:	0f 90       	pop	r0
     e94:	0f be       	out	0x3f, r0	; 63
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	4d c0       	rjmp	.+154    	; 0xf34 <xQueueGenericSend+0x108>
     e9a:	8c 81       	ldd	r24, Y+4	; 0x04
     e9c:	9d 81       	ldd	r25, Y+5	; 0x05
     e9e:	89 2b       	or	r24, r25
     ea0:	21 f4       	brne	.+8      	; 0xeaa <xQueueGenericSend+0x7e>
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	45 c0       	rjmp	.+138    	; 0xf34 <xQueueGenericSend+0x108>
     eaa:	d1 10       	cpse	r13, r1
     eac:	06 c0       	rjmp	.+12     	; 0xeba <xQueueGenericSend+0x8e>
     eae:	ce 01       	movw	r24, r28
     eb0:	01 96       	adiw	r24, 0x01	; 1
     eb2:	0e 94 df 0c 	call	0x19be	; 0x19be <vTaskSetTimeOutState>
     eb6:	dd 24       	eor	r13, r13
     eb8:	d3 94       	inc	r13
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63
     ebe:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	0f 92       	push	r0
     ec8:	f8 01       	movw	r30, r16
     eca:	85 8d       	ldd	r24, Z+29	; 0x1d
     ecc:	8f 3f       	cpi	r24, 0xFF	; 255
     ece:	09 f4       	brne	.+2      	; 0xed2 <xQueueGenericSend+0xa6>
     ed0:	15 8e       	std	Z+29, r1	; 0x1d
     ed2:	f8 01       	movw	r30, r16
     ed4:	86 8d       	ldd	r24, Z+30	; 0x1e
     ed6:	8f 3f       	cpi	r24, 0xFF	; 255
     ed8:	09 f4       	brne	.+2      	; 0xedc <xQueueGenericSend+0xb0>
     eda:	16 8e       	std	Z+30, r1	; 0x1e
     edc:	0f 90       	pop	r0
     ede:	0f be       	out	0x3f, r0	; 63
     ee0:	be 01       	movw	r22, r28
     ee2:	6c 5f       	subi	r22, 0xFC	; 252
     ee4:	7f 4f       	sbci	r23, 0xFF	; 255
     ee6:	ce 01       	movw	r24, r28
     ee8:	01 96       	adiw	r24, 0x01	; 1
     eea:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <xTaskCheckForTimeOut>
     eee:	81 11       	cpse	r24, r1
     ef0:	1b c0       	rjmp	.+54     	; 0xf28 <xQueueGenericSend+0xfc>
     ef2:	c8 01       	movw	r24, r16
     ef4:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <prvIsQueueFull>
     ef8:	88 23       	and	r24, r24
     efa:	81 f0       	breq	.+32     	; 0xf1c <xQueueGenericSend+0xf0>
     efc:	6c 81       	ldd	r22, Y+4	; 0x04
     efe:	7d 81       	ldd	r23, Y+5	; 0x05
     f00:	c8 01       	movw	r24, r16
     f02:	08 96       	adiw	r24, 0x08	; 8
     f04:	0e 94 85 0c 	call	0x190a	; 0x190a <vTaskPlaceOnEventList>
     f08:	c8 01       	movw	r24, r16
     f0a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
     f0e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
     f12:	81 11       	cpse	r24, r1
     f14:	9e cf       	rjmp	.-196    	; 0xe52 <xQueueGenericSend+0x26>
     f16:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
     f1a:	9b cf       	rjmp	.-202    	; 0xe52 <xQueueGenericSend+0x26>
     f1c:	c8 01       	movw	r24, r16
     f1e:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
     f22:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
     f26:	95 cf       	rjmp	.-214    	; 0xe52 <xQueueGenericSend+0x26>
     f28:	c8 01       	movw	r24, r16
     f2a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
     f2e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	1f 91       	pop	r17
     f44:	0f 91       	pop	r16
     f46:	ff 90       	pop	r15
     f48:	ef 90       	pop	r14
     f4a:	df 90       	pop	r13
     f4c:	cf 90       	pop	r12
     f4e:	08 95       	ret

00000f50 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     f50:	8f 92       	push	r8
     f52:	9f 92       	push	r9
     f54:	bf 92       	push	r11
     f56:	cf 92       	push	r12
     f58:	df 92       	push	r13
     f5a:	ef 92       	push	r14
     f5c:	ff 92       	push	r15
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	00 d0       	rcall	.+0      	; 0xf68 <xQueueGenericReceive+0x18>
     f68:	00 d0       	rcall	.+0      	; 0xf6a <xQueueGenericReceive+0x1a>
     f6a:	1f 92       	push	r1
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
     f70:	8c 01       	movw	r16, r24
     f72:	6b 01       	movw	r12, r22
     f74:	5d 83       	std	Y+5, r21	; 0x05
     f76:	4c 83       	std	Y+4, r20	; 0x04
     f78:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     f7a:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	f8 94       	cli
     f80:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f82:	f8 01       	movw	r30, r16
     f84:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f86:	ff 20       	and	r15, r15
     f88:	91 f1       	breq	.+100    	; 0xfee <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     f8a:	86 80       	ldd	r8, Z+6	; 0x06
     f8c:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     f8e:	b6 01       	movw	r22, r12
     f90:	c8 01       	movw	r24, r16
     f92:	0e 94 45 06 	call	0xc8a	; 0xc8a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     f96:	b1 10       	cpse	r11, r1
     f98:	19 c0       	rjmp	.+50     	; 0xfcc <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     f9a:	fa 94       	dec	r15
     f9c:	f8 01       	movw	r30, r16
     f9e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fa0:	80 81       	ld	r24, Z
     fa2:	91 81       	ldd	r25, Z+1	; 0x01
     fa4:	89 2b       	or	r24, r25
     fa6:	29 f4       	brne	.+10     	; 0xfb2 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     fa8:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <pvTaskIncrementMutexHeldCount>
     fac:	f8 01       	movw	r30, r16
     fae:	93 83       	std	Z+3, r25	; 0x03
     fb0:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fb2:	f8 01       	movw	r30, r16
     fb4:	80 85       	ldd	r24, Z+8	; 0x08
     fb6:	88 23       	and	r24, r24
     fb8:	b1 f0       	breq	.+44     	; 0xfe6 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fba:	c8 01       	movw	r24, r16
     fbc:	08 96       	adiw	r24, 0x08	; 8
     fbe:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     fc2:	88 23       	and	r24, r24
     fc4:	81 f0       	breq	.+32     	; 0xfe6 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     fc6:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
     fca:	0d c0       	rjmp	.+26     	; 0xfe6 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     fcc:	f8 01       	movw	r30, r16
     fce:	97 82       	std	Z+7, r9	; 0x07
     fd0:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fd2:	81 89       	ldd	r24, Z+17	; 0x11
     fd4:	88 23       	and	r24, r24
     fd6:	39 f0       	breq	.+14     	; 0xfe6 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fd8:	c8 01       	movw	r24, r16
     fda:	41 96       	adiw	r24, 0x11	; 17
     fdc:	0e 94 97 0c 	call	0x192e	; 0x192e <xTaskRemoveFromEventList>
     fe0:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     fe2:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     fe6:	0f 90       	pop	r0
     fe8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	61 c0       	rjmp	.+194    	; 0x10b0 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     fee:	8c 81       	ldd	r24, Y+4	; 0x04
     ff0:	9d 81       	ldd	r25, Y+5	; 0x05
     ff2:	89 2b       	or	r24, r25
     ff4:	21 f4       	brne	.+8      	; 0xffe <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ff6:	0f 90       	pop	r0
     ff8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	59 c0       	rjmp	.+178    	; 0x10b0 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
     ffe:	e1 10       	cpse	r14, r1
    1000:	06 c0       	rjmp	.+12     	; 0x100e <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1002:	ce 01       	movw	r24, r28
    1004:	01 96       	adiw	r24, 0x01	; 1
    1006:	0e 94 df 0c 	call	0x19be	; 0x19be <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    100a:	ee 24       	eor	r14, r14
    100c:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1012:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1016:	0f b6       	in	r0, 0x3f	; 63
    1018:	f8 94       	cli
    101a:	0f 92       	push	r0
    101c:	f8 01       	movw	r30, r16
    101e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1020:	8f 3f       	cpi	r24, 0xFF	; 255
    1022:	09 f4       	brne	.+2      	; 0x1026 <xQueueGenericReceive+0xd6>
    1024:	15 8e       	std	Z+29, r1	; 0x1d
    1026:	f8 01       	movw	r30, r16
    1028:	86 8d       	ldd	r24, Z+30	; 0x1e
    102a:	8f 3f       	cpi	r24, 0xFF	; 255
    102c:	09 f4       	brne	.+2      	; 0x1030 <xQueueGenericReceive+0xe0>
    102e:	16 8e       	std	Z+30, r1	; 0x1e
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1034:	be 01       	movw	r22, r28
    1036:	6c 5f       	subi	r22, 0xFC	; 252
    1038:	7f 4f       	sbci	r23, 0xFF	; 255
    103a:	ce 01       	movw	r24, r28
    103c:	01 96       	adiw	r24, 0x01	; 1
    103e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <xTaskCheckForTimeOut>
    1042:	81 11       	cpse	r24, r1
    1044:	29 c0       	rjmp	.+82     	; 0x1098 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1046:	c8 01       	movw	r24, r16
    1048:	0e 94 cb 05 	call	0xb96	; 0xb96 <prvIsQueueEmpty>
    104c:	88 23       	and	r24, r24
    104e:	f1 f0       	breq	.+60     	; 0x108c <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1050:	f8 01       	movw	r30, r16
    1052:	80 81       	ld	r24, Z
    1054:	91 81       	ldd	r25, Z+1	; 0x01
    1056:	89 2b       	or	r24, r25
    1058:	49 f4       	brne	.+18     	; 0x106c <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1060:	82 81       	ldd	r24, Z+2	; 0x02
    1062:	93 81       	ldd	r25, Z+3	; 0x03
    1064:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1068:	0f 90       	pop	r0
    106a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    106c:	6c 81       	ldd	r22, Y+4	; 0x04
    106e:	7d 81       	ldd	r23, Y+5	; 0x05
    1070:	c8 01       	movw	r24, r16
    1072:	41 96       	adiw	r24, 0x11	; 17
    1074:	0e 94 85 0c 	call	0x190a	; 0x190a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1078:	c8 01       	movw	r24, r16
    107a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    107e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
    1082:	81 11       	cpse	r24, r1
    1084:	7b cf       	rjmp	.-266    	; 0xf7c <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1086:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
    108a:	78 cf       	rjmp	.-272    	; 0xf7c <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    108c:	c8 01       	movw	r24, r16
    108e:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1092:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
    1096:	72 cf       	rjmp	.-284    	; 0xf7c <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1098:	c8 01       	movw	r24, r16
    109a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    109e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10a2:	c8 01       	movw	r24, r16
    10a4:	0e 94 cb 05 	call	0xb96	; 0xb96 <prvIsQueueEmpty>
    10a8:	88 23       	and	r24, r24
    10aa:	09 f4       	brne	.+2      	; 0x10ae <xQueueGenericReceive+0x15e>
    10ac:	67 cf       	rjmp	.-306    	; 0xf7c <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    10ae:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    10b0:	0f 90       	pop	r0
    10b2:	0f 90       	pop	r0
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	0f 90       	pop	r0
    10ba:	df 91       	pop	r29
    10bc:	cf 91       	pop	r28
    10be:	1f 91       	pop	r17
    10c0:	0f 91       	pop	r16
    10c2:	ff 90       	pop	r15
    10c4:	ef 90       	pop	r14
    10c6:	df 90       	pop	r13
    10c8:	cf 90       	pop	r12
    10ca:	bf 90       	pop	r11
    10cc:	9f 90       	pop	r9
    10ce:	8f 90       	pop	r8
    10d0:	08 95       	ret

000010d2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    10d2:	e0 91 1f 05 	lds	r30, 0x051F	; 0x80051f <pxDelayedTaskList>
    10d6:	f0 91 20 05 	lds	r31, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    10da:	80 81       	ld	r24, Z
    10dc:	81 11       	cpse	r24, r1
    10de:	07 c0       	rjmp	.+14     	; 0x10ee <prvResetNextTaskUnblockTime+0x1c>
    10e0:	8f ef       	ldi	r24, 0xFF	; 255
    10e2:	9f ef       	ldi	r25, 0xFF	; 255
    10e4:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    10e8:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <xNextTaskUnblockTime>
    10ec:	08 95       	ret
    10ee:	e0 91 1f 05 	lds	r30, 0x051F	; 0x80051f <pxDelayedTaskList>
    10f2:	f0 91 20 05 	lds	r31, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    10f6:	05 80       	ldd	r0, Z+5	; 0x05
    10f8:	f6 81       	ldd	r31, Z+6	; 0x06
    10fa:	e0 2d       	mov	r30, r0
    10fc:	06 80       	ldd	r0, Z+6	; 0x06
    10fe:	f7 81       	ldd	r31, Z+7	; 0x07
    1100:	e0 2d       	mov	r30, r0
    1102:	82 81       	ldd	r24, Z+2	; 0x02
    1104:	93 81       	ldd	r25, Z+3	; 0x03
    1106:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    110a:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <xNextTaskUnblockTime>
    110e:	08 95       	ret

00001110 <prvDeleteTCB>:
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	ec 01       	movw	r28, r24
    1116:	8f 89       	ldd	r24, Y+23	; 0x17
    1118:	98 8d       	ldd	r25, Y+24	; 0x18
    111a:	0e 94 b2 03 	call	0x764	; 0x764 <vPortFree>
    111e:	ce 01       	movw	r24, r28
    1120:	0e 94 b2 03 	call	0x764	; 0x764 <vPortFree>
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	08 95       	ret

0000112a <prvInitialiseNewTask>:
    112a:	6f 92       	push	r6
    112c:	7f 92       	push	r7
    112e:	8f 92       	push	r8
    1130:	9f 92       	push	r9
    1132:	af 92       	push	r10
    1134:	bf 92       	push	r11
    1136:	cf 92       	push	r12
    1138:	df 92       	push	r13
    113a:	ef 92       	push	r14
    113c:	0f 93       	push	r16
    113e:	1f 93       	push	r17
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	cd b7       	in	r28, 0x3d	; 61
    1146:	de b7       	in	r29, 0x3e	; 62
    1148:	4c 01       	movw	r8, r24
    114a:	f5 01       	movw	r30, r10
    114c:	87 89       	ldd	r24, Z+23	; 0x17
    114e:	90 8d       	ldd	r25, Z+24	; 0x18
    1150:	21 50       	subi	r18, 0x01	; 1
    1152:	31 09       	sbc	r19, r1
    1154:	3c 01       	movw	r6, r24
    1156:	62 0e       	add	r6, r18
    1158:	73 1e       	adc	r7, r19
    115a:	20 e0       	ldi	r18, 0x00	; 0
    115c:	0f c0       	rjmp	.+30     	; 0x117c <prvInitialiseNewTask+0x52>
    115e:	82 2f       	mov	r24, r18
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	fb 01       	movw	r30, r22
    1164:	e8 0f       	add	r30, r24
    1166:	f9 1f       	adc	r31, r25
    1168:	30 81       	ld	r19, Z
    116a:	d5 01       	movw	r26, r10
    116c:	a8 0f       	add	r26, r24
    116e:	b9 1f       	adc	r27, r25
    1170:	59 96       	adiw	r26, 0x19	; 25
    1172:	3c 93       	st	X, r19
    1174:	80 81       	ld	r24, Z
    1176:	88 23       	and	r24, r24
    1178:	19 f0       	breq	.+6      	; 0x1180 <prvInitialiseNewTask+0x56>
    117a:	2f 5f       	subi	r18, 0xFF	; 255
    117c:	28 30       	cpi	r18, 0x08	; 8
    117e:	78 f3       	brcs	.-34     	; 0x115e <prvInitialiseNewTask+0x34>
    1180:	f5 01       	movw	r30, r10
    1182:	10 a2       	std	Z+32, r1	; 0x20
    1184:	f6 e0       	ldi	r31, 0x06	; 6
    1186:	fe 15       	cp	r31, r14
    1188:	20 f4       	brcc	.+8      	; 0x1192 <prvInitialiseNewTask+0x68>
    118a:	0f 2e       	mov	r0, r31
    118c:	f6 e0       	ldi	r31, 0x06	; 6
    118e:	ef 2e       	mov	r14, r31
    1190:	f0 2d       	mov	r31, r0
    1192:	f5 01       	movw	r30, r10
    1194:	e6 8a       	std	Z+22, r14	; 0x16
    1196:	e1 a2       	std	Z+33, r14	; 0x21
    1198:	12 a2       	std	Z+34, r1	; 0x22
    119a:	c5 01       	movw	r24, r10
    119c:	02 96       	adiw	r24, 0x02	; 2
    119e:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <vListInitialiseItem>
    11a2:	c5 01       	movw	r24, r10
    11a4:	0c 96       	adiw	r24, 0x0c	; 12
    11a6:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <vListInitialiseItem>
    11aa:	f5 01       	movw	r30, r10
    11ac:	b1 86       	std	Z+9, r11	; 0x09
    11ae:	a0 86       	std	Z+8, r10	; 0x08
    11b0:	87 e0       	ldi	r24, 0x07	; 7
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	8e 19       	sub	r24, r14
    11b6:	91 09       	sbc	r25, r1
    11b8:	95 87       	std	Z+13, r25	; 0x0d
    11ba:	84 87       	std	Z+12, r24	; 0x0c
    11bc:	b3 8a       	std	Z+19, r11	; 0x13
    11be:	a2 8a       	std	Z+18, r10	; 0x12
    11c0:	13 a2       	std	Z+35, r1	; 0x23
    11c2:	14 a2       	std	Z+36, r1	; 0x24
    11c4:	15 a2       	std	Z+37, r1	; 0x25
    11c6:	16 a2       	std	Z+38, r1	; 0x26
    11c8:	17 a2       	std	Z+39, r1	; 0x27
    11ca:	a8 01       	movw	r20, r16
    11cc:	b4 01       	movw	r22, r8
    11ce:	c3 01       	movw	r24, r6
    11d0:	0e 94 78 04 	call	0x8f0	; 0x8f0 <pxPortInitialiseStack>
    11d4:	f5 01       	movw	r30, r10
    11d6:	91 83       	std	Z+1, r25	; 0x01
    11d8:	80 83       	st	Z, r24
    11da:	c1 14       	cp	r12, r1
    11dc:	d1 04       	cpc	r13, r1
    11de:	19 f0       	breq	.+6      	; 0x11e6 <prvInitialiseNewTask+0xbc>
    11e0:	f6 01       	movw	r30, r12
    11e2:	b1 82       	std	Z+1, r11	; 0x01
    11e4:	a0 82       	st	Z, r10
    11e6:	df 91       	pop	r29
    11e8:	cf 91       	pop	r28
    11ea:	1f 91       	pop	r17
    11ec:	0f 91       	pop	r16
    11ee:	ef 90       	pop	r14
    11f0:	df 90       	pop	r13
    11f2:	cf 90       	pop	r12
    11f4:	bf 90       	pop	r11
    11f6:	af 90       	pop	r10
    11f8:	9f 90       	pop	r9
    11fa:	8f 90       	pop	r8
    11fc:	7f 90       	pop	r7
    11fe:	6f 90       	pop	r6
    1200:	08 95       	ret

00001202 <prvInitialiseTaskLists>:
    1202:	cf 93       	push	r28
    1204:	c0 e0       	ldi	r28, 0x00	; 0
    1206:	10 c0       	rjmp	.+32     	; 0x1228 <prvInitialiseTaskLists+0x26>
    1208:	8c 2f       	mov	r24, r28
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	9c 01       	movw	r18, r24
    120e:	22 0f       	add	r18, r18
    1210:	33 1f       	adc	r19, r19
    1212:	22 0f       	add	r18, r18
    1214:	33 1f       	adc	r19, r19
    1216:	22 0f       	add	r18, r18
    1218:	33 1f       	adc	r19, r19
    121a:	82 0f       	add	r24, r18
    121c:	93 1f       	adc	r25, r19
    121e:	8d 5c       	subi	r24, 0xCD	; 205
    1220:	9a 4f       	sbci	r25, 0xFA	; 250
    1222:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    1226:	cf 5f       	subi	r28, 0xFF	; 255
    1228:	c7 30       	cpi	r28, 0x07	; 7
    122a:	70 f3       	brcs	.-36     	; 0x1208 <prvInitialiseTaskLists+0x6>
    122c:	8a e2       	ldi	r24, 0x2A	; 42
    122e:	95 e0       	ldi	r25, 0x05	; 5
    1230:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    1234:	81 e2       	ldi	r24, 0x21	; 33
    1236:	95 e0       	ldi	r25, 0x05	; 5
    1238:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    123c:	84 e1       	ldi	r24, 0x14	; 20
    123e:	95 e0       	ldi	r25, 0x05	; 5
    1240:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    1244:	8b e0       	ldi	r24, 0x0B	; 11
    1246:	95 e0       	ldi	r25, 0x05	; 5
    1248:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	95 e0       	ldi	r25, 0x05	; 5
    1250:	0e 94 e5 03 	call	0x7ca	; 0x7ca <vListInitialise>
    1254:	8a e2       	ldi	r24, 0x2A	; 42
    1256:	95 e0       	ldi	r25, 0x05	; 5
    1258:	90 93 20 05 	sts	0x0520, r25	; 0x800520 <pxDelayedTaskList+0x1>
    125c:	80 93 1f 05 	sts	0x051F, r24	; 0x80051f <pxDelayedTaskList>
    1260:	81 e2       	ldi	r24, 0x21	; 33
    1262:	95 e0       	ldi	r25, 0x05	; 5
    1264:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <pxOverflowDelayedTaskList+0x1>
    1268:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <pxOverflowDelayedTaskList>
    126c:	cf 91       	pop	r28
    126e:	08 95       	ret

00001270 <prvAddNewTaskToReadyList>:
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	ec 01       	movw	r28, r24
    1276:	0f b6       	in	r0, 0x3f	; 63
    1278:	f8 94       	cli
    127a:	0f 92       	push	r0
    127c:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxCurrentNumberOfTasks>
    1280:	8f 5f       	subi	r24, 0xFF	; 255
    1282:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <uxCurrentNumberOfTasks>
    1286:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <pxCurrentTCB>
    128a:	90 91 73 05 	lds	r25, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    128e:	89 2b       	or	r24, r25
    1290:	59 f4       	brne	.+22     	; 0x12a8 <prvAddNewTaskToReadyList+0x38>
    1292:	d0 93 73 05 	sts	0x0573, r29	; 0x800573 <pxCurrentTCB+0x1>
    1296:	c0 93 72 05 	sts	0x0572, r28	; 0x800572 <pxCurrentTCB>
    129a:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxCurrentNumberOfTasks>
    129e:	81 30       	cpi	r24, 0x01	; 1
    12a0:	99 f4       	brne	.+38     	; 0x12c8 <prvAddNewTaskToReadyList+0x58>
    12a2:	0e 94 01 09 	call	0x1202	; 0x1202 <prvInitialiseTaskLists>
    12a6:	10 c0       	rjmp	.+32     	; 0x12c8 <prvAddNewTaskToReadyList+0x58>
    12a8:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <xSchedulerRunning>
    12ac:	81 11       	cpse	r24, r1
    12ae:	0c c0       	rjmp	.+24     	; 0x12c8 <prvAddNewTaskToReadyList+0x58>
    12b0:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    12b4:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    12b8:	96 89       	ldd	r25, Z+22	; 0x16
    12ba:	8e 89       	ldd	r24, Y+22	; 0x16
    12bc:	89 17       	cp	r24, r25
    12be:	20 f0       	brcs	.+8      	; 0x12c8 <prvAddNewTaskToReadyList+0x58>
    12c0:	d0 93 73 05 	sts	0x0573, r29	; 0x800573 <pxCurrentTCB+0x1>
    12c4:	c0 93 72 05 	sts	0x0572, r28	; 0x800572 <pxCurrentTCB>
    12c8:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxTaskNumber>
    12cc:	8f 5f       	subi	r24, 0xFF	; 255
    12ce:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxTaskNumber>
    12d2:	8e 89       	ldd	r24, Y+22	; 0x16
    12d4:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    12d8:	98 17       	cp	r25, r24
    12da:	10 f4       	brcc	.+4      	; 0x12e0 <prvAddNewTaskToReadyList+0x70>
    12dc:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	9c 01       	movw	r18, r24
    12e4:	22 0f       	add	r18, r18
    12e6:	33 1f       	adc	r19, r19
    12e8:	22 0f       	add	r18, r18
    12ea:	33 1f       	adc	r19, r19
    12ec:	22 0f       	add	r18, r18
    12ee:	33 1f       	adc	r19, r19
    12f0:	82 0f       	add	r24, r18
    12f2:	93 1f       	adc	r25, r19
    12f4:	be 01       	movw	r22, r28
    12f6:	6e 5f       	subi	r22, 0xFE	; 254
    12f8:	7f 4f       	sbci	r23, 0xFF	; 255
    12fa:	8d 5c       	subi	r24, 0xCD	; 205
    12fc:	9a 4f       	sbci	r25, 0xFA	; 250
    12fe:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    1302:	0f 90       	pop	r0
    1304:	0f be       	out	0x3f, r0	; 63
    1306:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <xSchedulerRunning>
    130a:	88 23       	and	r24, r24
    130c:	51 f0       	breq	.+20     	; 0x1322 <prvAddNewTaskToReadyList+0xb2>
    130e:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    1312:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1316:	96 89       	ldd	r25, Z+22	; 0x16
    1318:	8e 89       	ldd	r24, Y+22	; 0x16
    131a:	98 17       	cp	r25, r24
    131c:	10 f4       	brcc	.+4      	; 0x1322 <prvAddNewTaskToReadyList+0xb2>
    131e:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
    1322:	df 91       	pop	r29
    1324:	cf 91       	pop	r28
    1326:	08 95       	ret

00001328 <prvAddCurrentTaskToDelayedList>:
    1328:	ff 92       	push	r15
    132a:	0f 93       	push	r16
    132c:	1f 93       	push	r17
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	ec 01       	movw	r28, r24
    1334:	f6 2e       	mov	r15, r22
    1336:	00 91 fe 04 	lds	r16, 0x04FE	; 0x8004fe <xTickCount>
    133a:	10 91 ff 04 	lds	r17, 0x04FF	; 0x8004ff <xTickCount+0x1>
    133e:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <pxCurrentTCB>
    1342:	90 91 73 05 	lds	r25, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1346:	02 96       	adiw	r24, 0x02	; 2
    1348:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    134c:	cf 3f       	cpi	r28, 0xFF	; 255
    134e:	8f ef       	ldi	r24, 0xFF	; 255
    1350:	d8 07       	cpc	r29, r24
    1352:	69 f4       	brne	.+26     	; 0x136e <prvAddCurrentTaskToDelayedList+0x46>
    1354:	ff 20       	and	r15, r15
    1356:	59 f0       	breq	.+22     	; 0x136e <prvAddCurrentTaskToDelayedList+0x46>
    1358:	60 91 72 05 	lds	r22, 0x0572	; 0x800572 <pxCurrentTCB>
    135c:	70 91 73 05 	lds	r23, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1360:	6e 5f       	subi	r22, 0xFE	; 254
    1362:	7f 4f       	sbci	r23, 0xFF	; 255
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	95 e0       	ldi	r25, 0x05	; 5
    1368:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    136c:	2f c0       	rjmp	.+94     	; 0x13cc <prvAddCurrentTaskToDelayedList+0xa4>
    136e:	c0 0f       	add	r28, r16
    1370:	d1 1f       	adc	r29, r17
    1372:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    1376:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    137a:	d3 83       	std	Z+3, r29	; 0x03
    137c:	c2 83       	std	Z+2, r28	; 0x02
    137e:	c0 17       	cp	r28, r16
    1380:	d1 07       	cpc	r29, r17
    1382:	68 f4       	brcc	.+26     	; 0x139e <prvAddCurrentTaskToDelayedList+0x76>
    1384:	60 91 72 05 	lds	r22, 0x0572	; 0x800572 <pxCurrentTCB>
    1388:	70 91 73 05 	lds	r23, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    138c:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <pxOverflowDelayedTaskList>
    1390:	90 91 1e 05 	lds	r25, 0x051E	; 0x80051e <pxOverflowDelayedTaskList+0x1>
    1394:	6e 5f       	subi	r22, 0xFE	; 254
    1396:	7f 4f       	sbci	r23, 0xFF	; 255
    1398:	0e 94 18 04 	call	0x830	; 0x830 <vListInsert>
    139c:	17 c0       	rjmp	.+46     	; 0x13cc <prvAddCurrentTaskToDelayedList+0xa4>
    139e:	60 91 72 05 	lds	r22, 0x0572	; 0x800572 <pxCurrentTCB>
    13a2:	70 91 73 05 	lds	r23, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    13a6:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <pxDelayedTaskList>
    13aa:	90 91 20 05 	lds	r25, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    13ae:	6e 5f       	subi	r22, 0xFE	; 254
    13b0:	7f 4f       	sbci	r23, 0xFF	; 255
    13b2:	0e 94 18 04 	call	0x830	; 0x830 <vListInsert>
    13b6:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <xNextTaskUnblockTime>
    13ba:	90 91 f7 04 	lds	r25, 0x04F7	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    13be:	c8 17       	cp	r28, r24
    13c0:	d9 07       	cpc	r29, r25
    13c2:	20 f4       	brcc	.+8      	; 0x13cc <prvAddCurrentTaskToDelayedList+0xa4>
    13c4:	d0 93 f7 04 	sts	0x04F7, r29	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    13c8:	c0 93 f6 04 	sts	0x04F6, r28	; 0x8004f6 <xNextTaskUnblockTime>
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	ff 90       	pop	r15
    13d6:	08 95       	ret

000013d8 <xTaskCreate>:
    13d8:	2f 92       	push	r2
    13da:	3f 92       	push	r3
    13dc:	4f 92       	push	r4
    13de:	5f 92       	push	r5
    13e0:	6f 92       	push	r6
    13e2:	7f 92       	push	r7
    13e4:	8f 92       	push	r8
    13e6:	9f 92       	push	r9
    13e8:	af 92       	push	r10
    13ea:	bf 92       	push	r11
    13ec:	cf 92       	push	r12
    13ee:	df 92       	push	r13
    13f0:	ef 92       	push	r14
    13f2:	ff 92       	push	r15
    13f4:	0f 93       	push	r16
    13f6:	1f 93       	push	r17
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	3c 01       	movw	r6, r24
    13fe:	1b 01       	movw	r2, r22
    1400:	5a 01       	movw	r10, r20
    1402:	29 01       	movw	r4, r18
    1404:	ca 01       	movw	r24, r20
    1406:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    140a:	6c 01       	movw	r12, r24
    140c:	89 2b       	or	r24, r25
    140e:	71 f0       	breq	.+28     	; 0x142c <xTaskCreate+0x54>
    1410:	88 e2       	ldi	r24, 0x28	; 40
    1412:	90 e0       	ldi	r25, 0x00	; 0
    1414:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    1418:	ec 01       	movw	r28, r24
    141a:	89 2b       	or	r24, r25
    141c:	19 f0       	breq	.+6      	; 0x1424 <xTaskCreate+0x4c>
    141e:	d8 8e       	std	Y+24, r13	; 0x18
    1420:	cf 8a       	std	Y+23, r12	; 0x17
    1422:	06 c0       	rjmp	.+12     	; 0x1430 <xTaskCreate+0x58>
    1424:	c6 01       	movw	r24, r12
    1426:	0e 94 b2 03 	call	0x764	; 0x764 <vPortFree>
    142a:	02 c0       	rjmp	.+4      	; 0x1430 <xTaskCreate+0x58>
    142c:	c0 e0       	ldi	r28, 0x00	; 0
    142e:	d0 e0       	ldi	r29, 0x00	; 0
    1430:	20 97       	sbiw	r28, 0x00	; 0
    1432:	91 f0       	breq	.+36     	; 0x1458 <xTaskCreate+0x80>
    1434:	95 01       	movw	r18, r10
    1436:	40 e0       	ldi	r20, 0x00	; 0
    1438:	50 e0       	ldi	r21, 0x00	; 0
    143a:	81 2c       	mov	r8, r1
    143c:	91 2c       	mov	r9, r1
    143e:	5e 01       	movw	r10, r28
    1440:	67 01       	movw	r12, r14
    1442:	e0 2e       	mov	r14, r16
    1444:	82 01       	movw	r16, r4
    1446:	b1 01       	movw	r22, r2
    1448:	c3 01       	movw	r24, r6
    144a:	0e 94 95 08 	call	0x112a	; 0x112a <prvInitialiseNewTask>
    144e:	ce 01       	movw	r24, r28
    1450:	0e 94 38 09 	call	0x1270	; 0x1270 <prvAddNewTaskToReadyList>
    1454:	81 e0       	ldi	r24, 0x01	; 1
    1456:	01 c0       	rjmp	.+2      	; 0x145a <xTaskCreate+0x82>
    1458:	8f ef       	ldi	r24, 0xFF	; 255
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	1f 91       	pop	r17
    1460:	0f 91       	pop	r16
    1462:	ff 90       	pop	r15
    1464:	ef 90       	pop	r14
    1466:	df 90       	pop	r13
    1468:	cf 90       	pop	r12
    146a:	bf 90       	pop	r11
    146c:	af 90       	pop	r10
    146e:	9f 90       	pop	r9
    1470:	8f 90       	pop	r8
    1472:	7f 90       	pop	r7
    1474:	6f 90       	pop	r6
    1476:	5f 90       	pop	r5
    1478:	4f 90       	pop	r4
    147a:	3f 90       	pop	r3
    147c:	2f 90       	pop	r2
    147e:	08 95       	ret

00001480 <vTaskStartScheduler>:
    1480:	ef 92       	push	r14
    1482:	ff 92       	push	r15
    1484:	0f 93       	push	r16
    1486:	0f 2e       	mov	r0, r31
    1488:	f4 ef       	ldi	r31, 0xF4	; 244
    148a:	ef 2e       	mov	r14, r31
    148c:	f4 e0       	ldi	r31, 0x04	; 4
    148e:	ff 2e       	mov	r15, r31
    1490:	f0 2d       	mov	r31, r0
    1492:	00 e0       	ldi	r16, 0x00	; 0
    1494:	20 e0       	ldi	r18, 0x00	; 0
    1496:	30 e0       	ldi	r19, 0x00	; 0
    1498:	40 e5       	ldi	r20, 0x50	; 80
    149a:	50 e0       	ldi	r21, 0x00	; 0
    149c:	6a ef       	ldi	r22, 0xFA	; 250
    149e:	70 e0       	ldi	r23, 0x00	; 0
    14a0:	80 ee       	ldi	r24, 0xE0	; 224
    14a2:	9b e0       	ldi	r25, 0x0B	; 11
    14a4:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <xTaskCreate>
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	81 f4       	brne	.+32     	; 0x14cc <vTaskStartScheduler+0x4c>
    14ac:	f8 94       	cli
    14ae:	8f ef       	ldi	r24, 0xFF	; 255
    14b0:	9f ef       	ldi	r25, 0xFF	; 255
    14b2:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    14b6:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <xNextTaskUnblockTime>
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	80 93 fc 04 	sts	0x04FC, r24	; 0x8004fc <xSchedulerRunning>
    14c0:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <xTickCount+0x1>
    14c4:	10 92 fe 04 	sts	0x04FE, r1	; 0x8004fe <xTickCount>
    14c8:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <xPortStartScheduler>
    14cc:	0f 91       	pop	r16
    14ce:	ff 90       	pop	r15
    14d0:	ef 90       	pop	r14
    14d2:	08 95       	ret

000014d4 <vTaskSuspendAll>:
    14d4:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    14d8:	8f 5f       	subi	r24, 0xFF	; 255
    14da:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <uxSchedulerSuspended>
    14de:	08 95       	ret

000014e0 <xTaskIncrementTick>:
    14e0:	df 92       	push	r13
    14e2:	ef 92       	push	r14
    14e4:	ff 92       	push	r15
    14e6:	0f 93       	push	r16
    14e8:	1f 93       	push	r17
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    14f2:	81 11       	cpse	r24, r1
    14f4:	97 c0       	rjmp	.+302    	; 0x1624 <xTaskIncrementTick+0x144>
    14f6:	e0 90 fe 04 	lds	r14, 0x04FE	; 0x8004fe <xTickCount>
    14fa:	f0 90 ff 04 	lds	r15, 0x04FF	; 0x8004ff <xTickCount+0x1>
    14fe:	8f ef       	ldi	r24, 0xFF	; 255
    1500:	e8 1a       	sub	r14, r24
    1502:	f8 0a       	sbc	r15, r24
    1504:	f0 92 ff 04 	sts	0x04FF, r15	; 0x8004ff <xTickCount+0x1>
    1508:	e0 92 fe 04 	sts	0x04FE, r14	; 0x8004fe <xTickCount>
    150c:	e1 14       	cp	r14, r1
    150e:	f1 04       	cpc	r15, r1
    1510:	b9 f4       	brne	.+46     	; 0x1540 <xTaskIncrementTick+0x60>
    1512:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <pxDelayedTaskList>
    1516:	90 91 20 05 	lds	r25, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    151a:	20 91 1d 05 	lds	r18, 0x051D	; 0x80051d <pxOverflowDelayedTaskList>
    151e:	30 91 1e 05 	lds	r19, 0x051E	; 0x80051e <pxOverflowDelayedTaskList+0x1>
    1522:	30 93 20 05 	sts	0x0520, r19	; 0x800520 <pxDelayedTaskList+0x1>
    1526:	20 93 1f 05 	sts	0x051F, r18	; 0x80051f <pxDelayedTaskList>
    152a:	90 93 1e 05 	sts	0x051E, r25	; 0x80051e <pxOverflowDelayedTaskList+0x1>
    152e:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <pxOverflowDelayedTaskList>
    1532:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <xNumOfOverflows>
    1536:	8f 5f       	subi	r24, 0xFF	; 255
    1538:	80 93 f9 04 	sts	0x04F9, r24	; 0x8004f9 <xNumOfOverflows>
    153c:	0e 94 69 08 	call	0x10d2	; 0x10d2 <prvResetNextTaskUnblockTime>
    1540:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <xNextTaskUnblockTime>
    1544:	90 91 f7 04 	lds	r25, 0x04F7	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    1548:	e8 16       	cp	r14, r24
    154a:	f9 06       	cpc	r15, r25
    154c:	28 f4       	brcc	.+10     	; 0x1558 <xTaskIncrementTick+0x78>
    154e:	d1 2c       	mov	r13, r1
    1550:	53 c0       	rjmp	.+166    	; 0x15f8 <xTaskIncrementTick+0x118>
    1552:	dd 24       	eor	r13, r13
    1554:	d3 94       	inc	r13
    1556:	01 c0       	rjmp	.+2      	; 0x155a <xTaskIncrementTick+0x7a>
    1558:	d1 2c       	mov	r13, r1
    155a:	e0 91 1f 05 	lds	r30, 0x051F	; 0x80051f <pxDelayedTaskList>
    155e:	f0 91 20 05 	lds	r31, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    1562:	80 81       	ld	r24, Z
    1564:	81 11       	cpse	r24, r1
    1566:	07 c0       	rjmp	.+14     	; 0x1576 <xTaskIncrementTick+0x96>
    1568:	8f ef       	ldi	r24, 0xFF	; 255
    156a:	9f ef       	ldi	r25, 0xFF	; 255
    156c:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    1570:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <xNextTaskUnblockTime>
    1574:	41 c0       	rjmp	.+130    	; 0x15f8 <xTaskIncrementTick+0x118>
    1576:	e0 91 1f 05 	lds	r30, 0x051F	; 0x80051f <pxDelayedTaskList>
    157a:	f0 91 20 05 	lds	r31, 0x0520	; 0x800520 <pxDelayedTaskList+0x1>
    157e:	05 80       	ldd	r0, Z+5	; 0x05
    1580:	f6 81       	ldd	r31, Z+6	; 0x06
    1582:	e0 2d       	mov	r30, r0
    1584:	c6 81       	ldd	r28, Z+6	; 0x06
    1586:	d7 81       	ldd	r29, Z+7	; 0x07
    1588:	8a 81       	ldd	r24, Y+2	; 0x02
    158a:	9b 81       	ldd	r25, Y+3	; 0x03
    158c:	e8 16       	cp	r14, r24
    158e:	f9 06       	cpc	r15, r25
    1590:	28 f4       	brcc	.+10     	; 0x159c <xTaskIncrementTick+0xbc>
    1592:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <xNextTaskUnblockTime+0x1>
    1596:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <xNextTaskUnblockTime>
    159a:	2e c0       	rjmp	.+92     	; 0x15f8 <xTaskIncrementTick+0x118>
    159c:	8e 01       	movw	r16, r28
    159e:	0e 5f       	subi	r16, 0xFE	; 254
    15a0:	1f 4f       	sbci	r17, 0xFF	; 255
    15a2:	c8 01       	movw	r24, r16
    15a4:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    15a8:	8c 89       	ldd	r24, Y+20	; 0x14
    15aa:	9d 89       	ldd	r25, Y+21	; 0x15
    15ac:	89 2b       	or	r24, r25
    15ae:	21 f0       	breq	.+8      	; 0x15b8 <xTaskIncrementTick+0xd8>
    15b0:	ce 01       	movw	r24, r28
    15b2:	0c 96       	adiw	r24, 0x0c	; 12
    15b4:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    15b8:	8e 89       	ldd	r24, Y+22	; 0x16
    15ba:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    15be:	98 17       	cp	r25, r24
    15c0:	10 f4       	brcc	.+4      	; 0x15c6 <xTaskIncrementTick+0xe6>
    15c2:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	9c 01       	movw	r18, r24
    15ca:	22 0f       	add	r18, r18
    15cc:	33 1f       	adc	r19, r19
    15ce:	22 0f       	add	r18, r18
    15d0:	33 1f       	adc	r19, r19
    15d2:	22 0f       	add	r18, r18
    15d4:	33 1f       	adc	r19, r19
    15d6:	82 0f       	add	r24, r18
    15d8:	93 1f       	adc	r25, r19
    15da:	b8 01       	movw	r22, r16
    15dc:	8d 5c       	subi	r24, 0xCD	; 205
    15de:	9a 4f       	sbci	r25, 0xFA	; 250
    15e0:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    15e4:	9e 89       	ldd	r25, Y+22	; 0x16
    15e6:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    15ea:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    15ee:	86 89       	ldd	r24, Z+22	; 0x16
    15f0:	98 17       	cp	r25, r24
    15f2:	08 f0       	brcs	.+2      	; 0x15f6 <xTaskIncrementTick+0x116>
    15f4:	ae cf       	rjmp	.-164    	; 0x1552 <xTaskIncrementTick+0x72>
    15f6:	b1 cf       	rjmp	.-158    	; 0x155a <xTaskIncrementTick+0x7a>
    15f8:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    15fc:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1600:	86 89       	ldd	r24, Z+22	; 0x16
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	fc 01       	movw	r30, r24
    1606:	ee 0f       	add	r30, r30
    1608:	ff 1f       	adc	r31, r31
    160a:	ee 0f       	add	r30, r30
    160c:	ff 1f       	adc	r31, r31
    160e:	ee 0f       	add	r30, r30
    1610:	ff 1f       	adc	r31, r31
    1612:	8e 0f       	add	r24, r30
    1614:	9f 1f       	adc	r25, r31
    1616:	fc 01       	movw	r30, r24
    1618:	ed 5c       	subi	r30, 0xCD	; 205
    161a:	fa 4f       	sbci	r31, 0xFA	; 250
    161c:	80 81       	ld	r24, Z
    161e:	82 30       	cpi	r24, 0x02	; 2
    1620:	40 f4       	brcc	.+16     	; 0x1632 <xTaskIncrementTick+0x152>
    1622:	09 c0       	rjmp	.+18     	; 0x1636 <xTaskIncrementTick+0x156>
    1624:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <uxPendedTicks>
    1628:	8f 5f       	subi	r24, 0xFF	; 255
    162a:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <uxPendedTicks>
    162e:	d1 2c       	mov	r13, r1
    1630:	02 c0       	rjmp	.+4      	; 0x1636 <xTaskIncrementTick+0x156>
    1632:	dd 24       	eor	r13, r13
    1634:	d3 94       	inc	r13
    1636:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <xYieldPending>
    163a:	88 23       	and	r24, r24
    163c:	11 f0       	breq	.+4      	; 0x1642 <xTaskIncrementTick+0x162>
    163e:	dd 24       	eor	r13, r13
    1640:	d3 94       	inc	r13
    1642:	8d 2d       	mov	r24, r13
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	0f 91       	pop	r16
    164c:	ff 90       	pop	r15
    164e:	ef 90       	pop	r14
    1650:	df 90       	pop	r13
    1652:	08 95       	ret

00001654 <xTaskResumeAll>:
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	f8 94       	cli
    1660:	0f 92       	push	r0
    1662:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    1666:	81 50       	subi	r24, 0x01	; 1
    1668:	80 93 f3 04 	sts	0x04F3, r24	; 0x8004f3 <uxSchedulerSuspended>
    166c:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    1670:	81 11       	cpse	r24, r1
    1672:	58 c0       	rjmp	.+176    	; 0x1724 <xTaskResumeAll+0xd0>
    1674:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxCurrentNumberOfTasks>
    1678:	81 11       	cpse	r24, r1
    167a:	33 c0       	rjmp	.+102    	; 0x16e2 <xTaskResumeAll+0x8e>
    167c:	56 c0       	rjmp	.+172    	; 0x172a <xTaskResumeAll+0xd6>
    167e:	e0 91 19 05 	lds	r30, 0x0519	; 0x800519 <xPendingReadyList+0x5>
    1682:	f0 91 1a 05 	lds	r31, 0x051A	; 0x80051a <xPendingReadyList+0x6>
    1686:	c6 81       	ldd	r28, Z+6	; 0x06
    1688:	d7 81       	ldd	r29, Z+7	; 0x07
    168a:	ce 01       	movw	r24, r28
    168c:	0c 96       	adiw	r24, 0x0c	; 12
    168e:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1692:	8e 01       	movw	r16, r28
    1694:	0e 5f       	subi	r16, 0xFE	; 254
    1696:	1f 4f       	sbci	r17, 0xFF	; 255
    1698:	c8 01       	movw	r24, r16
    169a:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    169e:	8e 89       	ldd	r24, Y+22	; 0x16
    16a0:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    16a4:	98 17       	cp	r25, r24
    16a6:	10 f4       	brcc	.+4      	; 0x16ac <xTaskResumeAll+0x58>
    16a8:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	9c 01       	movw	r18, r24
    16b0:	22 0f       	add	r18, r18
    16b2:	33 1f       	adc	r19, r19
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	82 0f       	add	r24, r18
    16be:	93 1f       	adc	r25, r19
    16c0:	b8 01       	movw	r22, r16
    16c2:	8d 5c       	subi	r24, 0xCD	; 205
    16c4:	9a 4f       	sbci	r25, 0xFA	; 250
    16c6:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    16ca:	9e 89       	ldd	r25, Y+22	; 0x16
    16cc:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    16d0:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    16d4:	86 89       	ldd	r24, Z+22	; 0x16
    16d6:	98 17       	cp	r25, r24
    16d8:	30 f0       	brcs	.+12     	; 0x16e6 <xTaskResumeAll+0x92>
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xYieldPending>
    16e0:	02 c0       	rjmp	.+4      	; 0x16e6 <xTaskResumeAll+0x92>
    16e2:	c0 e0       	ldi	r28, 0x00	; 0
    16e4:	d0 e0       	ldi	r29, 0x00	; 0
    16e6:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <xPendingReadyList>
    16ea:	81 11       	cpse	r24, r1
    16ec:	c8 cf       	rjmp	.-112    	; 0x167e <xTaskResumeAll+0x2a>
    16ee:	cd 2b       	or	r28, r29
    16f0:	11 f0       	breq	.+4      	; 0x16f6 <xTaskResumeAll+0xa2>
    16f2:	0e 94 69 08 	call	0x10d2	; 0x10d2 <prvResetNextTaskUnblockTime>
    16f6:	c0 91 fb 04 	lds	r28, 0x04FB	; 0x8004fb <uxPendedTicks>
    16fa:	cc 23       	and	r28, r28
    16fc:	59 f0       	breq	.+22     	; 0x1714 <xTaskResumeAll+0xc0>
    16fe:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <xTaskIncrementTick>
    1702:	88 23       	and	r24, r24
    1704:	19 f0       	breq	.+6      	; 0x170c <xTaskResumeAll+0xb8>
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xYieldPending>
    170c:	c1 50       	subi	r28, 0x01	; 1
    170e:	b9 f7       	brne	.-18     	; 0x16fe <xTaskResumeAll+0xaa>
    1710:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <uxPendedTicks>
    1714:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <xYieldPending>
    1718:	88 23       	and	r24, r24
    171a:	31 f0       	breq	.+12     	; 0x1728 <xTaskResumeAll+0xd4>
    171c:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	03 c0       	rjmp	.+6      	; 0x172a <xTaskResumeAll+0xd6>
    1724:	80 e0       	ldi	r24, 0x00	; 0
    1726:	01 c0       	rjmp	.+2      	; 0x172a <xTaskResumeAll+0xd6>
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	0f 90       	pop	r0
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	df 91       	pop	r29
    1730:	cf 91       	pop	r28
    1732:	1f 91       	pop	r17
    1734:	0f 91       	pop	r16
    1736:	08 95       	ret

00001738 <vTaskDelay>:
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	ec 01       	movw	r28, r24
    173e:	89 2b       	or	r24, r25
    1740:	49 f0       	breq	.+18     	; 0x1754 <vTaskDelay+0x1c>
    1742:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
    1746:	60 e0       	ldi	r22, 0x00	; 0
    1748:	ce 01       	movw	r24, r28
    174a:	0e 94 94 09 	call	0x1328	; 0x1328 <prvAddCurrentTaskToDelayedList>
    174e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
    1752:	01 c0       	rjmp	.+2      	; 0x1756 <vTaskDelay+0x1e>
    1754:	80 e0       	ldi	r24, 0x00	; 0
    1756:	81 11       	cpse	r24, r1
    1758:	02 c0       	rjmp	.+4      	; 0x175e <vTaskDelay+0x26>
    175a:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	08 95       	ret

00001764 <prvCheckTasksWaitingTermination>:
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	24 c0       	rjmp	.+72     	; 0x17b2 <prvCheckTasksWaitingTermination+0x4e>
    176a:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vTaskSuspendAll>
    176e:	c0 91 0b 05 	lds	r28, 0x050B	; 0x80050b <xTasksWaitingTermination>
    1772:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskResumeAll>
    1776:	cc 23       	and	r28, r28
    1778:	e1 f0       	breq	.+56     	; 0x17b2 <prvCheckTasksWaitingTermination+0x4e>
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	f8 94       	cli
    177e:	0f 92       	push	r0
    1780:	e0 91 10 05 	lds	r30, 0x0510	; 0x800510 <xTasksWaitingTermination+0x5>
    1784:	f0 91 11 05 	lds	r31, 0x0511	; 0x800511 <xTasksWaitingTermination+0x6>
    1788:	c6 81       	ldd	r28, Z+6	; 0x06
    178a:	d7 81       	ldd	r29, Z+7	; 0x07
    178c:	ce 01       	movw	r24, r28
    178e:	02 96       	adiw	r24, 0x02	; 2
    1790:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1794:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxCurrentNumberOfTasks>
    1798:	81 50       	subi	r24, 0x01	; 1
    179a:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <uxCurrentNumberOfTasks>
    179e:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxDeletedTasksWaitingCleanUp>
    17a2:	81 50       	subi	r24, 0x01	; 1
    17a4:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <uxDeletedTasksWaitingCleanUp>
    17a8:	0f 90       	pop	r0
    17aa:	0f be       	out	0x3f, r0	; 63
    17ac:	ce 01       	movw	r24, r28
    17ae:	0e 94 88 08 	call	0x1110	; 0x1110 <prvDeleteTCB>
    17b2:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxDeletedTasksWaitingCleanUp>
    17b6:	81 11       	cpse	r24, r1
    17b8:	d8 cf       	rjmp	.-80     	; 0x176a <prvCheckTasksWaitingTermination+0x6>
    17ba:	df 91       	pop	r29
    17bc:	cf 91       	pop	r28
    17be:	08 95       	ret

000017c0 <prvIdleTask>:
    17c0:	0e 94 b2 0b 	call	0x1764	; 0x1764 <prvCheckTasksWaitingTermination>
    17c4:	fd cf       	rjmp	.-6      	; 0x17c0 <prvIdleTask>

000017c6 <vTaskSwitchContext>:
    17c6:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    17ca:	88 23       	and	r24, r24
    17cc:	21 f0       	breq	.+8      	; 0x17d6 <vTaskSwitchContext+0x10>
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xYieldPending>
    17d4:	08 95       	ret
    17d6:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <xYieldPending>
    17da:	20 91 fd 04 	lds	r18, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    17de:	01 c0       	rjmp	.+2      	; 0x17e2 <vTaskSwitchContext+0x1c>
    17e0:	21 50       	subi	r18, 0x01	; 1
    17e2:	82 2f       	mov	r24, r18
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	fc 01       	movw	r30, r24
    17e8:	ee 0f       	add	r30, r30
    17ea:	ff 1f       	adc	r31, r31
    17ec:	ee 0f       	add	r30, r30
    17ee:	ff 1f       	adc	r31, r31
    17f0:	ee 0f       	add	r30, r30
    17f2:	ff 1f       	adc	r31, r31
    17f4:	e8 0f       	add	r30, r24
    17f6:	f9 1f       	adc	r31, r25
    17f8:	ed 5c       	subi	r30, 0xCD	; 205
    17fa:	fa 4f       	sbci	r31, 0xFA	; 250
    17fc:	30 81       	ld	r19, Z
    17fe:	33 23       	and	r19, r19
    1800:	79 f3       	breq	.-34     	; 0x17e0 <vTaskSwitchContext+0x1a>
    1802:	ac 01       	movw	r20, r24
    1804:	44 0f       	add	r20, r20
    1806:	55 1f       	adc	r21, r21
    1808:	44 0f       	add	r20, r20
    180a:	55 1f       	adc	r21, r21
    180c:	44 0f       	add	r20, r20
    180e:	55 1f       	adc	r21, r21
    1810:	48 0f       	add	r20, r24
    1812:	59 1f       	adc	r21, r25
    1814:	df 01       	movw	r26, r30
    1816:	01 80       	ldd	r0, Z+1	; 0x01
    1818:	f2 81       	ldd	r31, Z+2	; 0x02
    181a:	e0 2d       	mov	r30, r0
    181c:	02 80       	ldd	r0, Z+2	; 0x02
    181e:	f3 81       	ldd	r31, Z+3	; 0x03
    1820:	e0 2d       	mov	r30, r0
    1822:	12 96       	adiw	r26, 0x02	; 2
    1824:	fc 93       	st	X, r31
    1826:	ee 93       	st	-X, r30
    1828:	11 97       	sbiw	r26, 0x01	; 1
    182a:	4a 5c       	subi	r20, 0xCA	; 202
    182c:	5a 4f       	sbci	r21, 0xFA	; 250
    182e:	e4 17       	cp	r30, r20
    1830:	f5 07       	cpc	r31, r21
    1832:	29 f4       	brne	.+10     	; 0x183e <vTaskSwitchContext+0x78>
    1834:	42 81       	ldd	r20, Z+2	; 0x02
    1836:	53 81       	ldd	r21, Z+3	; 0x03
    1838:	fd 01       	movw	r30, r26
    183a:	52 83       	std	Z+2, r21	; 0x02
    183c:	41 83       	std	Z+1, r20	; 0x01
    183e:	fc 01       	movw	r30, r24
    1840:	ee 0f       	add	r30, r30
    1842:	ff 1f       	adc	r31, r31
    1844:	ee 0f       	add	r30, r30
    1846:	ff 1f       	adc	r31, r31
    1848:	ee 0f       	add	r30, r30
    184a:	ff 1f       	adc	r31, r31
    184c:	8e 0f       	add	r24, r30
    184e:	9f 1f       	adc	r25, r31
    1850:	fc 01       	movw	r30, r24
    1852:	ed 5c       	subi	r30, 0xCD	; 205
    1854:	fa 4f       	sbci	r31, 0xFA	; 250
    1856:	01 80       	ldd	r0, Z+1	; 0x01
    1858:	f2 81       	ldd	r31, Z+2	; 0x02
    185a:	e0 2d       	mov	r30, r0
    185c:	86 81       	ldd	r24, Z+6	; 0x06
    185e:	97 81       	ldd	r25, Z+7	; 0x07
    1860:	90 93 73 05 	sts	0x0573, r25	; 0x800573 <pxCurrentTCB+0x1>
    1864:	80 93 72 05 	sts	0x0572, r24	; 0x800572 <pxCurrentTCB>
    1868:	20 93 fd 04 	sts	0x04FD, r18	; 0x8004fd <uxTopReadyPriority>
    186c:	08 95       	ret

0000186e <vTaskSuspend>:
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	ec 01       	movw	r28, r24
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
    187e:	89 2b       	or	r24, r25
    1880:	21 f4       	brne	.+8      	; 0x188a <vTaskSuspend+0x1c>
    1882:	c0 91 72 05 	lds	r28, 0x0572	; 0x800572 <pxCurrentTCB>
    1886:	d0 91 73 05 	lds	r29, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    188a:	8e 01       	movw	r16, r28
    188c:	0e 5f       	subi	r16, 0xFE	; 254
    188e:	1f 4f       	sbci	r17, 0xFF	; 255
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1896:	8c 89       	ldd	r24, Y+20	; 0x14
    1898:	9d 89       	ldd	r25, Y+21	; 0x15
    189a:	89 2b       	or	r24, r25
    189c:	21 f0       	breq	.+8      	; 0x18a6 <vTaskSuspend+0x38>
    189e:	ce 01       	movw	r24, r28
    18a0:	0c 96       	adiw	r24, 0x0c	; 12
    18a2:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    18a6:	b8 01       	movw	r22, r16
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	95 e0       	ldi	r25, 0x05	; 5
    18ac:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    18b0:	0f 90       	pop	r0
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <xSchedulerRunning>
    18b8:	88 23       	and	r24, r24
    18ba:	39 f0       	breq	.+14     	; 0x18ca <vTaskSuspend+0x5c>
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	0f 92       	push	r0
    18c2:	0e 94 69 08 	call	0x10d2	; 0x10d2 <prvResetNextTaskUnblockTime>
    18c6:	0f 90       	pop	r0
    18c8:	0f be       	out	0x3f, r0	; 63
    18ca:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <pxCurrentTCB>
    18ce:	90 91 73 05 	lds	r25, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    18d2:	c8 17       	cp	r28, r24
    18d4:	d9 07       	cpc	r29, r25
    18d6:	a1 f4       	brne	.+40     	; 0x1900 <vTaskSuspend+0x92>
    18d8:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <xSchedulerRunning>
    18dc:	88 23       	and	r24, r24
    18de:	19 f0       	breq	.+6      	; 0x18e6 <vTaskSuspend+0x78>
    18e0:	0e 94 13 05 	call	0xa26	; 0xa26 <vPortYield>
    18e4:	0d c0       	rjmp	.+26     	; 0x1900 <vTaskSuspend+0x92>
    18e6:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <xSuspendedTaskList>
    18ea:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxCurrentNumberOfTasks>
    18ee:	98 13       	cpse	r25, r24
    18f0:	05 c0       	rjmp	.+10     	; 0x18fc <vTaskSuspend+0x8e>
    18f2:	10 92 73 05 	sts	0x0573, r1	; 0x800573 <pxCurrentTCB+0x1>
    18f6:	10 92 72 05 	sts	0x0572, r1	; 0x800572 <pxCurrentTCB>
    18fa:	02 c0       	rjmp	.+4      	; 0x1900 <vTaskSuspend+0x92>
    18fc:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <vTaskSwitchContext>
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	1f 91       	pop	r17
    1906:	0f 91       	pop	r16
    1908:	08 95       	ret

0000190a <vTaskPlaceOnEventList>:
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	eb 01       	movw	r28, r22
    1910:	60 91 72 05 	lds	r22, 0x0572	; 0x800572 <pxCurrentTCB>
    1914:	70 91 73 05 	lds	r23, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1918:	64 5f       	subi	r22, 0xF4	; 244
    191a:	7f 4f       	sbci	r23, 0xFF	; 255
    191c:	0e 94 18 04 	call	0x830	; 0x830 <vListInsert>
    1920:	61 e0       	ldi	r22, 0x01	; 1
    1922:	ce 01       	movw	r24, r28
    1924:	0e 94 94 09 	call	0x1328	; 0x1328 <prvAddCurrentTaskToDelayedList>
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	08 95       	ret

0000192e <xTaskRemoveFromEventList>:
    192e:	0f 93       	push	r16
    1930:	1f 93       	push	r17
    1932:	cf 93       	push	r28
    1934:	df 93       	push	r29
    1936:	dc 01       	movw	r26, r24
    1938:	15 96       	adiw	r26, 0x05	; 5
    193a:	ed 91       	ld	r30, X+
    193c:	fc 91       	ld	r31, X
    193e:	16 97       	sbiw	r26, 0x06	; 6
    1940:	c6 81       	ldd	r28, Z+6	; 0x06
    1942:	d7 81       	ldd	r29, Z+7	; 0x07
    1944:	8e 01       	movw	r16, r28
    1946:	04 5f       	subi	r16, 0xF4	; 244
    1948:	1f 4f       	sbci	r17, 0xFF	; 255
    194a:	c8 01       	movw	r24, r16
    194c:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1950:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <uxSchedulerSuspended>
    1954:	81 11       	cpse	r24, r1
    1956:	1c c0       	rjmp	.+56     	; 0x1990 <xTaskRemoveFromEventList+0x62>
    1958:	0a 50       	subi	r16, 0x0A	; 10
    195a:	11 09       	sbc	r17, r1
    195c:	c8 01       	movw	r24, r16
    195e:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1962:	8e 89       	ldd	r24, Y+22	; 0x16
    1964:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    1968:	98 17       	cp	r25, r24
    196a:	10 f4       	brcc	.+4      	; 0x1970 <xTaskRemoveFromEventList+0x42>
    196c:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	9c 01       	movw	r18, r24
    1974:	22 0f       	add	r18, r18
    1976:	33 1f       	adc	r19, r19
    1978:	22 0f       	add	r18, r18
    197a:	33 1f       	adc	r19, r19
    197c:	22 0f       	add	r18, r18
    197e:	33 1f       	adc	r19, r19
    1980:	82 0f       	add	r24, r18
    1982:	93 1f       	adc	r25, r19
    1984:	b8 01       	movw	r22, r16
    1986:	8d 5c       	subi	r24, 0xCD	; 205
    1988:	9a 4f       	sbci	r25, 0xFA	; 250
    198a:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    198e:	05 c0       	rjmp	.+10     	; 0x199a <xTaskRemoveFromEventList+0x6c>
    1990:	b8 01       	movw	r22, r16
    1992:	84 e1       	ldi	r24, 0x14	; 20
    1994:	95 e0       	ldi	r25, 0x05	; 5
    1996:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    199a:	9e 89       	ldd	r25, Y+22	; 0x16
    199c:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    19a0:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    19a4:	86 89       	ldd	r24, Z+22	; 0x16
    19a6:	89 17       	cp	r24, r25
    19a8:	20 f4       	brcc	.+8      	; 0x19b2 <xTaskRemoveFromEventList+0x84>
    19aa:	81 e0       	ldi	r24, 0x01	; 1
    19ac:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xYieldPending>
    19b0:	01 c0       	rjmp	.+2      	; 0x19b4 <xTaskRemoveFromEventList+0x86>
    19b2:	80 e0       	ldi	r24, 0x00	; 0
    19b4:	df 91       	pop	r29
    19b6:	cf 91       	pop	r28
    19b8:	1f 91       	pop	r17
    19ba:	0f 91       	pop	r16
    19bc:	08 95       	ret

000019be <vTaskSetTimeOutState>:
    19be:	20 91 f9 04 	lds	r18, 0x04F9	; 0x8004f9 <xNumOfOverflows>
    19c2:	fc 01       	movw	r30, r24
    19c4:	20 83       	st	Z, r18
    19c6:	20 91 fe 04 	lds	r18, 0x04FE	; 0x8004fe <xTickCount>
    19ca:	30 91 ff 04 	lds	r19, 0x04FF	; 0x8004ff <xTickCount+0x1>
    19ce:	32 83       	std	Z+2, r19	; 0x02
    19d0:	21 83       	std	Z+1, r18	; 0x01
    19d2:	08 95       	ret

000019d4 <xTaskCheckForTimeOut>:
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	0f 92       	push	r0
    19da:	40 91 fe 04 	lds	r20, 0x04FE	; 0x8004fe <xTickCount>
    19de:	50 91 ff 04 	lds	r21, 0x04FF	; 0x8004ff <xTickCount+0x1>
    19e2:	db 01       	movw	r26, r22
    19e4:	2d 91       	ld	r18, X+
    19e6:	3c 91       	ld	r19, X
    19e8:	2f 3f       	cpi	r18, 0xFF	; 255
    19ea:	bf ef       	ldi	r27, 0xFF	; 255
    19ec:	3b 07       	cpc	r19, r27
    19ee:	19 f1       	breq	.+70     	; 0x1a36 <xTaskCheckForTimeOut+0x62>
    19f0:	dc 01       	movw	r26, r24
    19f2:	fc 91       	ld	r31, X
    19f4:	e0 91 f9 04 	lds	r30, 0x04F9	; 0x8004f9 <xNumOfOverflows>
    19f8:	fe 17       	cp	r31, r30
    19fa:	39 f0       	breq	.+14     	; 0x1a0a <xTaskCheckForTimeOut+0x36>
    19fc:	11 96       	adiw	r26, 0x01	; 1
    19fe:	ed 91       	ld	r30, X+
    1a00:	fc 91       	ld	r31, X
    1a02:	12 97       	sbiw	r26, 0x02	; 2
    1a04:	4e 17       	cp	r20, r30
    1a06:	5f 07       	cpc	r21, r31
    1a08:	c0 f4       	brcc	.+48     	; 0x1a3a <xTaskCheckForTimeOut+0x66>
    1a0a:	dc 01       	movw	r26, r24
    1a0c:	11 96       	adiw	r26, 0x01	; 1
    1a0e:	ed 91       	ld	r30, X+
    1a10:	fc 91       	ld	r31, X
    1a12:	12 97       	sbiw	r26, 0x02	; 2
    1a14:	da 01       	movw	r26, r20
    1a16:	ae 1b       	sub	r26, r30
    1a18:	bf 0b       	sbc	r27, r31
    1a1a:	a2 17       	cp	r26, r18
    1a1c:	b3 07       	cpc	r27, r19
    1a1e:	78 f4       	brcc	.+30     	; 0x1a3e <xTaskCheckForTimeOut+0x6a>
    1a20:	db 01       	movw	r26, r22
    1a22:	e4 1b       	sub	r30, r20
    1a24:	f5 0b       	sbc	r31, r21
    1a26:	2e 0f       	add	r18, r30
    1a28:	3f 1f       	adc	r19, r31
    1a2a:	2d 93       	st	X+, r18
    1a2c:	3c 93       	st	X, r19
    1a2e:	0e 94 df 0c 	call	0x19be	; 0x19be <vTaskSetTimeOutState>
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	05 c0       	rjmp	.+10     	; 0x1a40 <xTaskCheckForTimeOut+0x6c>
    1a36:	80 e0       	ldi	r24, 0x00	; 0
    1a38:	03 c0       	rjmp	.+6      	; 0x1a40 <xTaskCheckForTimeOut+0x6c>
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	01 c0       	rjmp	.+2      	; 0x1a40 <xTaskCheckForTimeOut+0x6c>
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	0f 90       	pop	r0
    1a42:	0f be       	out	0x3f, r0	; 63
    1a44:	08 95       	ret

00001a46 <vTaskMissedYield>:
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <xYieldPending>
    1a4c:	08 95       	ret

00001a4e <vTaskPriorityInherit>:
    1a4e:	0f 93       	push	r16
    1a50:	1f 93       	push	r17
    1a52:	cf 93       	push	r28
    1a54:	df 93       	push	r29
    1a56:	fc 01       	movw	r30, r24
    1a58:	89 2b       	or	r24, r25
    1a5a:	09 f4       	brne	.+2      	; 0x1a5e <vTaskPriorityInherit+0x10>
    1a5c:	55 c0       	rjmp	.+170    	; 0x1b08 <vTaskPriorityInherit+0xba>
    1a5e:	26 89       	ldd	r18, Z+22	; 0x16
    1a60:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
    1a64:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1a68:	56 96       	adiw	r26, 0x16	; 22
    1a6a:	8c 91       	ld	r24, X
    1a6c:	28 17       	cp	r18, r24
    1a6e:	08 f0       	brcs	.+2      	; 0x1a72 <vTaskPriorityInherit+0x24>
    1a70:	4b c0       	rjmp	.+150    	; 0x1b08 <vTaskPriorityInherit+0xba>
    1a72:	84 85       	ldd	r24, Z+12	; 0x0c
    1a74:	95 85       	ldd	r25, Z+13	; 0x0d
    1a76:	99 23       	and	r25, r25
    1a78:	64 f0       	brlt	.+24     	; 0x1a92 <vTaskPriorityInherit+0x44>
    1a7a:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
    1a7e:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1a82:	56 96       	adiw	r26, 0x16	; 22
    1a84:	3c 91       	ld	r19, X
    1a86:	87 e0       	ldi	r24, 0x07	; 7
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	83 1b       	sub	r24, r19
    1a8c:	91 09       	sbc	r25, r1
    1a8e:	95 87       	std	Z+13, r25	; 0x0d
    1a90:	84 87       	std	Z+12, r24	; 0x0c
    1a92:	82 85       	ldd	r24, Z+10	; 0x0a
    1a94:	93 85       	ldd	r25, Z+11	; 0x0b
    1a96:	30 e0       	ldi	r19, 0x00	; 0
    1a98:	a9 01       	movw	r20, r18
    1a9a:	44 0f       	add	r20, r20
    1a9c:	55 1f       	adc	r21, r21
    1a9e:	44 0f       	add	r20, r20
    1aa0:	55 1f       	adc	r21, r21
    1aa2:	44 0f       	add	r20, r20
    1aa4:	55 1f       	adc	r21, r21
    1aa6:	24 0f       	add	r18, r20
    1aa8:	35 1f       	adc	r19, r21
    1aaa:	2d 5c       	subi	r18, 0xCD	; 205
    1aac:	3a 4f       	sbci	r19, 0xFA	; 250
    1aae:	82 17       	cp	r24, r18
    1ab0:	93 07       	cpc	r25, r19
    1ab2:	19 f5       	brne	.+70     	; 0x1afa <vTaskPriorityInherit+0xac>
    1ab4:	8f 01       	movw	r16, r30
    1ab6:	ef 01       	movw	r28, r30
    1ab8:	22 96       	adiw	r28, 0x02	; 2
    1aba:	ce 01       	movw	r24, r28
    1abc:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1ac0:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    1ac4:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1ac8:	86 89       	ldd	r24, Z+22	; 0x16
    1aca:	f8 01       	movw	r30, r16
    1acc:	86 8b       	std	Z+22, r24	; 0x16
    1ace:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    1ad2:	98 17       	cp	r25, r24
    1ad4:	10 f4       	brcc	.+4      	; 0x1ada <vTaskPriorityInherit+0x8c>
    1ad6:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	9c 01       	movw	r18, r24
    1ade:	22 0f       	add	r18, r18
    1ae0:	33 1f       	adc	r19, r19
    1ae2:	22 0f       	add	r18, r18
    1ae4:	33 1f       	adc	r19, r19
    1ae6:	22 0f       	add	r18, r18
    1ae8:	33 1f       	adc	r19, r19
    1aea:	82 0f       	add	r24, r18
    1aec:	93 1f       	adc	r25, r19
    1aee:	be 01       	movw	r22, r28
    1af0:	8d 5c       	subi	r24, 0xCD	; 205
    1af2:	9a 4f       	sbci	r25, 0xFA	; 250
    1af4:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    1af8:	07 c0       	rjmp	.+14     	; 0x1b08 <vTaskPriorityInherit+0xba>
    1afa:	a0 91 72 05 	lds	r26, 0x0572	; 0x800572 <pxCurrentTCB>
    1afe:	b0 91 73 05 	lds	r27, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1b02:	56 96       	adiw	r26, 0x16	; 22
    1b04:	8c 91       	ld	r24, X
    1b06:	86 8b       	std	Z+22, r24	; 0x16
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	1f 91       	pop	r17
    1b0e:	0f 91       	pop	r16
    1b10:	08 95       	ret

00001b12 <xTaskPriorityDisinherit>:
    1b12:	0f 93       	push	r16
    1b14:	1f 93       	push	r17
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	89 2b       	or	r24, r25
    1b1e:	79 f1       	breq	.+94     	; 0x1b7e <xTaskPriorityDisinherit+0x6c>
    1b20:	82 a1       	ldd	r24, Z+34	; 0x22
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	82 a3       	std	Z+34, r24	; 0x22
    1b26:	26 89       	ldd	r18, Z+22	; 0x16
    1b28:	91 a1       	ldd	r25, Z+33	; 0x21
    1b2a:	29 17       	cp	r18, r25
    1b2c:	51 f1       	breq	.+84     	; 0x1b82 <xTaskPriorityDisinherit+0x70>
    1b2e:	81 11       	cpse	r24, r1
    1b30:	2a c0       	rjmp	.+84     	; 0x1b86 <xTaskPriorityDisinherit+0x74>
    1b32:	ef 01       	movw	r28, r30
    1b34:	8f 01       	movw	r16, r30
    1b36:	0e 5f       	subi	r16, 0xFE	; 254
    1b38:	1f 4f       	sbci	r17, 0xFF	; 255
    1b3a:	c8 01       	movw	r24, r16
    1b3c:	0e 94 49 04 	call	0x892	; 0x892 <uxListRemove>
    1b40:	89 a1       	ldd	r24, Y+33	; 0x21
    1b42:	8e 8b       	std	Y+22, r24	; 0x16
    1b44:	27 e0       	ldi	r18, 0x07	; 7
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	28 1b       	sub	r18, r24
    1b4a:	31 09       	sbc	r19, r1
    1b4c:	3d 87       	std	Y+13, r19	; 0x0d
    1b4e:	2c 87       	std	Y+12, r18	; 0x0c
    1b50:	90 91 fd 04 	lds	r25, 0x04FD	; 0x8004fd <uxTopReadyPriority>
    1b54:	98 17       	cp	r25, r24
    1b56:	10 f4       	brcc	.+4      	; 0x1b5c <xTaskPriorityDisinherit+0x4a>
    1b58:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTopReadyPriority>
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	9c 01       	movw	r18, r24
    1b60:	22 0f       	add	r18, r18
    1b62:	33 1f       	adc	r19, r19
    1b64:	22 0f       	add	r18, r18
    1b66:	33 1f       	adc	r19, r19
    1b68:	22 0f       	add	r18, r18
    1b6a:	33 1f       	adc	r19, r19
    1b6c:	82 0f       	add	r24, r18
    1b6e:	93 1f       	adc	r25, r19
    1b70:	b8 01       	movw	r22, r16
    1b72:	8d 5c       	subi	r24, 0xCD	; 205
    1b74:	9a 4f       	sbci	r25, 0xFA	; 250
    1b76:	0e 94 f7 03 	call	0x7ee	; 0x7ee <vListInsertEnd>
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	05 c0       	rjmp	.+10     	; 0x1b88 <xTaskPriorityDisinherit+0x76>
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
    1b80:	03 c0       	rjmp	.+6      	; 0x1b88 <xTaskPriorityDisinherit+0x76>
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	01 c0       	rjmp	.+2      	; 0x1b88 <xTaskPriorityDisinherit+0x76>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	df 91       	pop	r29
    1b8a:	cf 91       	pop	r28
    1b8c:	1f 91       	pop	r17
    1b8e:	0f 91       	pop	r16
    1b90:	08 95       	ret

00001b92 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1b92:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <pxCurrentTCB>
    1b96:	90 91 73 05 	lds	r25, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1b9a:	89 2b       	or	r24, r25
    1b9c:	39 f0       	breq	.+14     	; 0x1bac <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1b9e:	e0 91 72 05 	lds	r30, 0x0572	; 0x800572 <pxCurrentTCB>
    1ba2:	f0 91 73 05 	lds	r31, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
    1ba6:	82 a1       	ldd	r24, Z+34	; 0x22
    1ba8:	8f 5f       	subi	r24, 0xFF	; 255
    1baa:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1bac:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <pxCurrentTCB>
    1bb0:	90 91 73 05 	lds	r25, 0x0573	; 0x800573 <pxCurrentTCB+0x1>
	}
    1bb4:	08 95       	ret

00001bb6 <LCD_voidSHD>:
	  LCD_voidSendData(pattern) ; 
	  
	  
	
	
}
    1bb6:	0f 93       	push	r16
    1bb8:	1f 93       	push	r17
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	00 d0       	rcall	.+0      	; 0x1bc0 <LCD_voidSHD+0xa>
    1bc0:	00 d0       	rcall	.+0      	; 0x1bc2 <LCD_voidSHD+0xc>
    1bc2:	cd b7       	in	r28, 0x3d	; 61
    1bc4:	de b7       	in	r29, 0x3e	; 62
    1bc6:	08 2f       	mov	r16, r24
    1bc8:	84 e0       	ldi	r24, 0x04	; 4
    1bca:	89 83       	std	Y+1, r24	; 0x01
    1bcc:	85 e0       	ldi	r24, 0x05	; 5
    1bce:	8a 83       	std	Y+2, r24	; 0x02
    1bd0:	86 e0       	ldi	r24, 0x06	; 6
    1bd2:	8b 83       	std	Y+3, r24	; 0x03
    1bd4:	87 e0       	ldi	r24, 0x07	; 7
    1bd6:	8c 83       	std	Y+4, r24	; 0x04
    1bd8:	10 e0       	ldi	r17, 0x00	; 0
    1bda:	14 c0       	rjmp	.+40     	; 0x1c04 <LCD_voidSHD+0x4e>
    1bdc:	40 2f       	mov	r20, r16
    1bde:	50 e0       	ldi	r21, 0x00	; 0
    1be0:	01 2e       	mov	r0, r17
    1be2:	02 c0       	rjmp	.+4      	; 0x1be8 <LCD_voidSHD+0x32>
    1be4:	55 95       	asr	r21
    1be6:	47 95       	ror	r20
    1be8:	0a 94       	dec	r0
    1bea:	e2 f7       	brpl	.-8      	; 0x1be4 <LCD_voidSHD+0x2e>
    1bec:	41 70       	andi	r20, 0x01	; 1
    1bee:	e1 e0       	ldi	r30, 0x01	; 1
    1bf0:	f0 e0       	ldi	r31, 0x00	; 0
    1bf2:	ec 0f       	add	r30, r28
    1bf4:	fd 1f       	adc	r31, r29
    1bf6:	e1 0f       	add	r30, r17
    1bf8:	f1 1d       	adc	r31, r1
    1bfa:	60 81       	ld	r22, Z
    1bfc:	80 e0       	ldi	r24, 0x00	; 0
    1bfe:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c02:	1f 5f       	subi	r17, 0xFF	; 255
    1c04:	14 30       	cpi	r17, 0x04	; 4
    1c06:	50 f3       	brcs	.-44     	; 0x1bdc <LCD_voidSHD+0x26>
    1c08:	0f 90       	pop	r0
    1c0a:	0f 90       	pop	r0
    1c0c:	0f 90       	pop	r0
    1c0e:	0f 90       	pop	r0
    1c10:	df 91       	pop	r29
    1c12:	cf 91       	pop	r28
    1c14:	1f 91       	pop	r17
    1c16:	0f 91       	pop	r16
    1c18:	08 95       	ret

00001c1a <LCD_voidSendEnable>:
    1c1a:	41 e0       	ldi	r20, 0x01	; 1
    1c1c:	62 e0       	ldi	r22, 0x02	; 2
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c24:	8f e3       	ldi	r24, 0x3F	; 63
    1c26:	9f e1       	ldi	r25, 0x1F	; 31
    1c28:	01 97       	sbiw	r24, 0x01	; 1
    1c2a:	f1 f7       	brne	.-4      	; 0x1c28 <LCD_voidSendEnable+0xe>
    1c2c:	00 c0       	rjmp	.+0      	; 0x1c2e <LCD_voidSendEnable+0x14>
    1c2e:	00 00       	nop
    1c30:	40 e0       	ldi	r20, 0x00	; 0
    1c32:	62 e0       	ldi	r22, 0x02	; 2
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c3a:	08 95       	ret

00001c3c <LCD_voidSendData>:
    1c3c:	cf 93       	push	r28
    1c3e:	c8 2f       	mov	r28, r24
    1c40:	41 e0       	ldi	r20, 0x01	; 1
    1c42:	60 e0       	ldi	r22, 0x00	; 0
    1c44:	81 e0       	ldi	r24, 0x01	; 1
    1c46:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c4a:	40 e0       	ldi	r20, 0x00	; 0
    1c4c:	61 e0       	ldi	r22, 0x01	; 1
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c54:	8c 2f       	mov	r24, r28
    1c56:	82 95       	swap	r24
    1c58:	8f 70       	andi	r24, 0x0F	; 15
    1c5a:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1c5e:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1c62:	8c 2f       	mov	r24, r28
    1c64:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1c68:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1c6c:	cf 91       	pop	r28
    1c6e:	08 95       	ret

00001c70 <LCD_voidSendCommand>:
    1c70:	cf 93       	push	r28
    1c72:	c8 2f       	mov	r28, r24
    1c74:	40 e0       	ldi	r20, 0x00	; 0
    1c76:	60 e0       	ldi	r22, 0x00	; 0
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c7e:	40 e0       	ldi	r20, 0x00	; 0
    1c80:	61 e0       	ldi	r22, 0x01	; 1
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DIO_voidSetPinVal>
    1c88:	8c 2f       	mov	r24, r28
    1c8a:	82 95       	swap	r24
    1c8c:	8f 70       	andi	r24, 0x0F	; 15
    1c8e:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1c92:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1c96:	8c 2f       	mov	r24, r28
    1c98:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1c9c:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1ca0:	cf 91       	pop	r28
    1ca2:	08 95       	ret

00001ca4 <LCD_voidInit>:
    1ca4:	2f ef       	ldi	r18, 0xFF	; 255
    1ca6:	83 ef       	ldi	r24, 0xF3	; 243
    1ca8:	91 e0       	ldi	r25, 0x01	; 1
    1caa:	21 50       	subi	r18, 0x01	; 1
    1cac:	80 40       	sbci	r24, 0x00	; 0
    1cae:	90 40       	sbci	r25, 0x00	; 0
    1cb0:	e1 f7       	brne	.-8      	; 0x1caa <LCD_voidInit+0x6>
    1cb2:	00 c0       	rjmp	.+0      	; 0x1cb4 <LCD_voidInit+0x10>
    1cb4:	00 00       	nop
    1cb6:	82 e0       	ldi	r24, 0x02	; 2
    1cb8:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1cbc:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1cc0:	82 e0       	ldi	r24, 0x02	; 2
    1cc2:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1cc6:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1cca:	88 e0       	ldi	r24, 0x08	; 8
    1ccc:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <LCD_voidSHD>
    1cd0:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <LCD_voidSendEnable>
    1cd4:	8c e0       	ldi	r24, 0x0C	; 12
    1cd6:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <LCD_voidSendCommand>
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <LCD_voidSendCommand>
    1ce0:	08 95       	ret

00001ce2 <LCD_voidSendString>:
    1ce2:	0f 93       	push	r16
    1ce4:	1f 93       	push	r17
    1ce6:	cf 93       	push	r28
    1ce8:	8c 01       	movw	r16, r24
    1cea:	c0 e0       	ldi	r28, 0x00	; 0
    1cec:	03 c0       	rjmp	.+6      	; 0x1cf4 <LCD_voidSendString+0x12>
    1cee:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <LCD_voidSendData>
    1cf2:	cf 5f       	subi	r28, 0xFF	; 255
    1cf4:	f8 01       	movw	r30, r16
    1cf6:	ec 0f       	add	r30, r28
    1cf8:	f1 1d       	adc	r31, r1
    1cfa:	80 81       	ld	r24, Z
    1cfc:	81 11       	cpse	r24, r1
    1cfe:	f7 cf       	rjmp	.-18     	; 0x1cee <LCD_voidSendString+0xc>
    1d00:	cf 91       	pop	r28
    1d02:	1f 91       	pop	r17
    1d04:	0f 91       	pop	r16
    1d06:	08 95       	ret

00001d08 <LCD_voidGotoxy>:
    1d08:	90 e4       	ldi	r25, 0x40	; 64
    1d0a:	69 9f       	mul	r22, r25
    1d0c:	80 0d       	add	r24, r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	80 68       	ori	r24, 0x80	; 128
    1d12:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <LCD_voidSendCommand>
    1d16:	08 95       	ret

00001d18 <LCD_voidSendNumber>:
void LCD_voidSendNumber(u32 number){
    1d18:	1f 93       	push	r17
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	cd b7       	in	r28, 0x3d	; 61
    1d20:	de b7       	in	r29, 0x3e	; 62
    1d22:	2a 97       	sbiw	r28, 0x0a	; 10
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	de bf       	out	0x3e, r29	; 62
    1d2a:	0f be       	out	0x3f, r0	; 63
    1d2c:	cd bf       	out	0x3d, r28	; 61
	
	s8 i=0;
	u8 array[10] ;
	
	if(number==0){
    1d2e:	61 15       	cp	r22, r1
    1d30:	71 05       	cpc	r23, r1
    1d32:	81 05       	cpc	r24, r1
    1d34:	91 05       	cpc	r25, r1
    1d36:	d1 f4       	brne	.+52     	; 0x1d6c <LCD_voidSendNumber+0x54>
		
		LCD_voidSendData('0') ;
    1d38:	80 e3       	ldi	r24, 0x30	; 48
    1d3a:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <LCD_voidSendData>
    1d3e:	2c c0       	rjmp	.+88     	; 0x1d98 <LCD_voidSendNumber+0x80>
		return ;
	}
	for(i=0; number!=0 ;i++){
		
		array[i]= number % 10 + 48 ;
    1d40:	2a e0       	ldi	r18, 0x0A	; 10
    1d42:	30 e0       	ldi	r19, 0x00	; 0
    1d44:	40 e0       	ldi	r20, 0x00	; 0
    1d46:	50 e0       	ldi	r21, 0x00	; 0
    1d48:	0e 94 64 11 	call	0x22c8	; 0x22c8 <__udivmodsi4>
    1d4c:	e1 e0       	ldi	r30, 0x01	; 1
    1d4e:	f0 e0       	ldi	r31, 0x00	; 0
    1d50:	ec 0f       	add	r30, r28
    1d52:	fd 1f       	adc	r31, r29
    1d54:	e1 0f       	add	r30, r17
    1d56:	f1 1d       	adc	r31, r1
    1d58:	17 fd       	sbrc	r17, 7
    1d5a:	fa 95       	dec	r31
    1d5c:	60 5d       	subi	r22, 0xD0	; 208
    1d5e:	60 83       	st	Z, r22
		number /= 10 ;
    1d60:	62 2f       	mov	r22, r18
    1d62:	73 2f       	mov	r23, r19
    1d64:	84 2f       	mov	r24, r20
    1d66:	95 2f       	mov	r25, r21
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
    1d68:	1f 5f       	subi	r17, 0xFF	; 255
    1d6a:	01 c0       	rjmp	.+2      	; 0x1d6e <LCD_voidSendNumber+0x56>
    1d6c:	10 e0       	ldi	r17, 0x00	; 0
    1d6e:	61 15       	cp	r22, r1
    1d70:	71 05       	cpc	r23, r1
    1d72:	81 05       	cpc	r24, r1
    1d74:	91 05       	cpc	r25, r1
    1d76:	21 f7       	brne	.-56     	; 0x1d40 <LCD_voidSendNumber+0x28>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
    1d78:	11 50       	subi	r17, 0x01	; 1
	while(i >= 0){
    1d7a:	0c c0       	rjmp	.+24     	; 0x1d94 <LCD_voidSendNumber+0x7c>
		
		LCD_voidSendData(array[i]) ;
    1d7c:	e1 e0       	ldi	r30, 0x01	; 1
    1d7e:	f0 e0       	ldi	r31, 0x00	; 0
    1d80:	ec 0f       	add	r30, r28
    1d82:	fd 1f       	adc	r31, r29
    1d84:	e1 0f       	add	r30, r17
    1d86:	f1 1d       	adc	r31, r1
    1d88:	17 fd       	sbrc	r17, 7
    1d8a:	fa 95       	dec	r31
    1d8c:	80 81       	ld	r24, Z
    1d8e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <LCD_voidSendData>
		i-- ;
    1d92:	11 50       	subi	r17, 0x01	; 1
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
    1d94:	11 23       	and	r17, r17
    1d96:	94 f7       	brge	.-28     	; 0x1d7c <LCD_voidSendNumber+0x64>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
    1d98:	2a 96       	adiw	r28, 0x0a	; 10
    1d9a:	0f b6       	in	r0, 0x3f	; 63
    1d9c:	f8 94       	cli
    1d9e:	de bf       	out	0x3e, r29	; 62
    1da0:	0f be       	out	0x3f, r0	; 63
    1da2:	cd bf       	out	0x3d, r28	; 61
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17
    1daa:	08 95       	ret

00001dac <ADC_voidInit>:


void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
    1dac:	87 b1       	in	r24, 0x07	; 7
    1dae:	8f 77       	andi	r24, 0x7F	; 127
    1db0:	87 b9       	out	0x07, r24	; 7
	 SET_BIT(ADMUX_REG,6) ; 
    1db2:	87 b1       	in	r24, 0x07	; 7
    1db4:	80 64       	ori	r24, 0x40	; 64
    1db6:	87 b9       	out	0x07, r24	; 7
	 
	/*select prescaler */
	 
	 ADCSRA_REG&=0b11111000 ; 
    1db8:	86 b1       	in	r24, 0x06	; 6
    1dba:	88 7f       	andi	r24, 0xF8	; 248
    1dbc:	86 b9       	out	0x06, r24	; 6
	 ADCSRA_REG|=ADC_PRESCALER ; 
    1dbe:	86 b1       	in	r24, 0x06	; 6
    1dc0:	87 60       	ori	r24, 0x07	; 7
    1dc2:	86 b9       	out	0x06, r24	; 6
	
	
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
    1dc4:	86 b1       	in	r24, 0x06	; 6
    1dc6:	80 68       	ori	r24, 0x80	; 128
    1dc8:	86 b9       	out	0x06, r24	; 6
    1dca:	08 95       	ret

00001dcc <ADC_u16ReadChannel>:
}

u16 ADC_u16ReadChannel(u8 copy_u8channel){
	
	  /* select channel */
	  ADMUX_REG &=0b11100000 ; 
    1dcc:	97 b1       	in	r25, 0x07	; 7
    1dce:	90 7e       	andi	r25, 0xE0	; 224
    1dd0:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG |=copy_u8channel ; 
    1dd2:	97 b1       	in	r25, 0x07	; 7
    1dd4:	89 2b       	or	r24, r25
    1dd6:	87 b9       	out	0x07, r24	; 7
	  /* start conversion */
	  SET_BIT(ADCSRA_REG,6) ; 
    1dd8:	86 b1       	in	r24, 0x06	; 6
    1dda:	80 64       	ori	r24, 0x40	; 64
    1ddc:	86 b9       	out	0x06, r24	; 6
	  
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
    1dde:	34 9b       	sbis	0x06, 4	; 6
    1de0:	fe cf       	rjmp	.-4      	; 0x1dde <ADC_u16ReadChannel+0x12>
	  
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
    1de2:	86 b1       	in	r24, 0x06	; 6
    1de4:	80 61       	ori	r24, 0x10	; 16
    1de6:	86 b9       	out	0x06, r24	; 6
	  
	  return  ADC_REG ; 
    1de8:	84 b1       	in	r24, 0x04	; 4
    1dea:	95 b1       	in	r25, 0x05	; 5

    1dec:	08 95       	ret

00001dee <DIO_voidSetPinVal>:
	
	
	return Loc_u8Val ; 
	
	
}
    1dee:	42 30       	cpi	r20, 0x02	; 2
    1df0:	08 f0       	brcs	.+2      	; 0x1df4 <DIO_voidSetPinVal+0x6>
    1df2:	6f c0       	rjmp	.+222    	; 0x1ed2 <DIO_voidSetPinVal+0xe4>
    1df4:	41 30       	cpi	r20, 0x01	; 1
    1df6:	a1 f5       	brne	.+104    	; 0x1e60 <DIO_voidSetPinVal+0x72>
    1df8:	81 30       	cpi	r24, 0x01	; 1
    1dfa:	89 f0       	breq	.+34     	; 0x1e1e <DIO_voidSetPinVal+0x30>
    1dfc:	28 f0       	brcs	.+10     	; 0x1e08 <DIO_voidSetPinVal+0x1a>
    1dfe:	82 30       	cpi	r24, 0x02	; 2
    1e00:	c9 f0       	breq	.+50     	; 0x1e34 <DIO_voidSetPinVal+0x46>
    1e02:	83 30       	cpi	r24, 0x03	; 3
    1e04:	11 f1       	breq	.+68     	; 0x1e4a <DIO_voidSetPinVal+0x5c>
    1e06:	08 95       	ret
    1e08:	2b b3       	in	r18, 0x1b	; 27
    1e0a:	81 e0       	ldi	r24, 0x01	; 1
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	02 c0       	rjmp	.+4      	; 0x1e14 <DIO_voidSetPinVal+0x26>
    1e10:	88 0f       	add	r24, r24
    1e12:	99 1f       	adc	r25, r25
    1e14:	6a 95       	dec	r22
    1e16:	e2 f7       	brpl	.-8      	; 0x1e10 <DIO_voidSetPinVal+0x22>
    1e18:	82 2b       	or	r24, r18
    1e1a:	8b bb       	out	0x1b, r24	; 27
    1e1c:	08 95       	ret
    1e1e:	28 b3       	in	r18, 0x18	; 24
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	90 e0       	ldi	r25, 0x00	; 0
    1e24:	02 c0       	rjmp	.+4      	; 0x1e2a <DIO_voidSetPinVal+0x3c>
    1e26:	88 0f       	add	r24, r24
    1e28:	99 1f       	adc	r25, r25
    1e2a:	6a 95       	dec	r22
    1e2c:	e2 f7       	brpl	.-8      	; 0x1e26 <DIO_voidSetPinVal+0x38>
    1e2e:	82 2b       	or	r24, r18
    1e30:	88 bb       	out	0x18, r24	; 24
    1e32:	08 95       	ret
    1e34:	25 b3       	in	r18, 0x15	; 21
    1e36:	81 e0       	ldi	r24, 0x01	; 1
    1e38:	90 e0       	ldi	r25, 0x00	; 0
    1e3a:	02 c0       	rjmp	.+4      	; 0x1e40 <DIO_voidSetPinVal+0x52>
    1e3c:	88 0f       	add	r24, r24
    1e3e:	99 1f       	adc	r25, r25
    1e40:	6a 95       	dec	r22
    1e42:	e2 f7       	brpl	.-8      	; 0x1e3c <DIO_voidSetPinVal+0x4e>
    1e44:	82 2b       	or	r24, r18
    1e46:	85 bb       	out	0x15, r24	; 21
    1e48:	08 95       	ret
    1e4a:	22 b3       	in	r18, 0x12	; 18
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	02 c0       	rjmp	.+4      	; 0x1e56 <DIO_voidSetPinVal+0x68>
    1e52:	88 0f       	add	r24, r24
    1e54:	99 1f       	adc	r25, r25
    1e56:	6a 95       	dec	r22
    1e58:	e2 f7       	brpl	.-8      	; 0x1e52 <DIO_voidSetPinVal+0x64>
    1e5a:	82 2b       	or	r24, r18
    1e5c:	82 bb       	out	0x12, r24	; 18
    1e5e:	08 95       	ret
    1e60:	41 11       	cpse	r20, r1
    1e62:	37 c0       	rjmp	.+110    	; 0x1ed2 <DIO_voidSetPinVal+0xe4>
    1e64:	81 30       	cpi	r24, 0x01	; 1
    1e66:	91 f0       	breq	.+36     	; 0x1e8c <DIO_voidSetPinVal+0x9e>
    1e68:	28 f0       	brcs	.+10     	; 0x1e74 <DIO_voidSetPinVal+0x86>
    1e6a:	82 30       	cpi	r24, 0x02	; 2
    1e6c:	d9 f0       	breq	.+54     	; 0x1ea4 <DIO_voidSetPinVal+0xb6>
    1e6e:	83 30       	cpi	r24, 0x03	; 3
    1e70:	29 f1       	breq	.+74     	; 0x1ebc <DIO_voidSetPinVal+0xce>
    1e72:	08 95       	ret
    1e74:	2b b3       	in	r18, 0x1b	; 27
    1e76:	81 e0       	ldi	r24, 0x01	; 1
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	02 c0       	rjmp	.+4      	; 0x1e80 <DIO_voidSetPinVal+0x92>
    1e7c:	88 0f       	add	r24, r24
    1e7e:	99 1f       	adc	r25, r25
    1e80:	6a 95       	dec	r22
    1e82:	e2 f7       	brpl	.-8      	; 0x1e7c <DIO_voidSetPinVal+0x8e>
    1e84:	80 95       	com	r24
    1e86:	82 23       	and	r24, r18
    1e88:	8b bb       	out	0x1b, r24	; 27
    1e8a:	08 95       	ret
    1e8c:	28 b3       	in	r18, 0x18	; 24
    1e8e:	81 e0       	ldi	r24, 0x01	; 1
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	02 c0       	rjmp	.+4      	; 0x1e98 <DIO_voidSetPinVal+0xaa>
    1e94:	88 0f       	add	r24, r24
    1e96:	99 1f       	adc	r25, r25
    1e98:	6a 95       	dec	r22
    1e9a:	e2 f7       	brpl	.-8      	; 0x1e94 <DIO_voidSetPinVal+0xa6>
    1e9c:	80 95       	com	r24
    1e9e:	82 23       	and	r24, r18
    1ea0:	88 bb       	out	0x18, r24	; 24
    1ea2:	08 95       	ret
    1ea4:	25 b3       	in	r18, 0x15	; 21
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	02 c0       	rjmp	.+4      	; 0x1eb0 <DIO_voidSetPinVal+0xc2>
    1eac:	88 0f       	add	r24, r24
    1eae:	99 1f       	adc	r25, r25
    1eb0:	6a 95       	dec	r22
    1eb2:	e2 f7       	brpl	.-8      	; 0x1eac <DIO_voidSetPinVal+0xbe>
    1eb4:	80 95       	com	r24
    1eb6:	82 23       	and	r24, r18
    1eb8:	85 bb       	out	0x15, r24	; 21
    1eba:	08 95       	ret
    1ebc:	22 b3       	in	r18, 0x12	; 18
    1ebe:	81 e0       	ldi	r24, 0x01	; 1
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	02 c0       	rjmp	.+4      	; 0x1ec8 <DIO_voidSetPinVal+0xda>
    1ec4:	88 0f       	add	r24, r24
    1ec6:	99 1f       	adc	r25, r25
    1ec8:	6a 95       	dec	r22
    1eca:	e2 f7       	brpl	.-8      	; 0x1ec4 <DIO_voidSetPinVal+0xd6>
    1ecc:	80 95       	com	r24
    1ece:	82 23       	and	r24, r18
    1ed0:	82 bb       	out	0x12, r24	; 18
    1ed2:	08 95       	ret

00001ed4 <DIO_voidSetPortDir>:


void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir){
	
	switch(copy_u8port){
    1ed4:	81 30       	cpi	r24, 0x01	; 1
    1ed6:	41 f0       	breq	.+16     	; 0x1ee8 <DIO_voidSetPortDir+0x14>
    1ed8:	28 f0       	brcs	.+10     	; 0x1ee4 <DIO_voidSetPortDir+0x10>
    1eda:	82 30       	cpi	r24, 0x02	; 2
    1edc:	39 f0       	breq	.+14     	; 0x1eec <DIO_voidSetPortDir+0x18>
    1ede:	83 30       	cpi	r24, 0x03	; 3
    1ee0:	39 f0       	breq	.+14     	; 0x1ef0 <DIO_voidSetPortDir+0x1c>
    1ee2:	08 95       	ret
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ;break ; 
    1ee4:	6a bb       	out	0x1a, r22	; 26
    1ee6:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ;break ;
    1ee8:	67 bb       	out	0x17, r22	; 23
    1eea:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ;break ;
    1eec:	64 bb       	out	0x14, r22	; 20
    1eee:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ;break ;
    1ef0:	61 bb       	out	0x11, r22	; 17
    1ef2:	08 95       	ret

00001ef4 <GI_voidEnable>:



void GI_voidEnable(void) {
	
	SET_BIT(SREG_REG,L_BIT) ;  //    SREG | =1<<7  --> 
    1ef4:	8f b7       	in	r24, 0x3f	; 63
    1ef6:	80 68       	ori	r24, 0x80	; 128
    1ef8:	8f bf       	out	0x3f, r24	; 63
    1efa:	08 95       	ret

00001efc <TIMER0_voidFastPWM>:
}

void TIMER0_voidFastPWM (u8 copy_u8dc) {
	
	/*select mode : fast pwm*/
	SET_BIT(TCCR0_REG, 3);
    1efc:	93 b7       	in	r25, 0x33	; 51
    1efe:	98 60       	ori	r25, 0x08	; 8
    1f00:	93 bf       	out	0x33, r25	; 51
	SET_BIT(TCCR0_REG, 6);
    1f02:	93 b7       	in	r25, 0x33	; 51
    1f04:	90 64       	ori	r25, 0x40	; 64
    1f06:	93 bf       	out	0x33, r25	; 51
	
	/*non inverting*/
	SET_BIT(TCCR0_REG, 5);
    1f08:	93 b7       	in	r25, 0x33	; 51
    1f0a:	90 62       	ori	r25, 0x20	; 32
    1f0c:	93 bf       	out	0x33, r25	; 51
	CLR_BIT(TCCR0_REG, 4);
    1f0e:	93 b7       	in	r25, 0x33	; 51
    1f10:	9f 7e       	andi	r25, 0xEF	; 239
    1f12:	93 bf       	out	0x33, r25	; 51
	
	/*set prescaler*/
	TCCR0_REG &= 0b11111000 ;
    1f14:	93 b7       	in	r25, 0x33	; 51
    1f16:	98 7f       	andi	r25, 0xF8	; 248
    1f18:	93 bf       	out	0x33, r25	; 51
	TCCR0_REG |= TIME0_PRESCALER;
    1f1a:	93 b7       	in	r25, 0x33	; 51
    1f1c:	93 60       	ori	r25, 0x03	; 3
    1f1e:	93 bf       	out	0x33, r25	; 51
	
	OCR0_REG = copy_u8dc * 2.55 ;
    1f20:	68 2f       	mov	r22, r24
    1f22:	70 e0       	ldi	r23, 0x00	; 0
    1f24:	80 e0       	ldi	r24, 0x00	; 0
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	0e 94 2e 10 	call	0x205c	; 0x205c <__floatsisf>
    1f2c:	23 e3       	ldi	r18, 0x33	; 51
    1f2e:	33 e3       	ldi	r19, 0x33	; 51
    1f30:	43 e2       	ldi	r20, 0x23	; 35
    1f32:	50 e4       	ldi	r21, 0x40	; 64
    1f34:	0e 94 97 10 	call	0x212e	; 0x212e <__mulsf3>
    1f38:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <__fixunssfsi>
    1f3c:	6c bf       	out	0x3c, r22	; 60
    1f3e:	08 95       	ret

00001f40 <__vector_11>:
	
}


void __vector_11(void)__attribute__((signal)) ;
void __vector_11(void){
    1f40:	1f 92       	push	r1
    1f42:	0f 92       	push	r0
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	0f 92       	push	r0
    1f48:	11 24       	eor	r1, r1
    1f4a:	2f 93       	push	r18
    1f4c:	3f 93       	push	r19
    1f4e:	4f 93       	push	r20
    1f50:	5f 93       	push	r21
    1f52:	6f 93       	push	r22
    1f54:	7f 93       	push	r23
    1f56:	8f 93       	push	r24
    1f58:	9f 93       	push	r25
    1f5a:	af 93       	push	r26
    1f5c:	bf 93       	push	r27
    1f5e:	ef 93       	push	r30
    1f60:	ff 93       	push	r31
	

	TIM0_PTR[0]() ; 
    1f62:	e0 91 74 05 	lds	r30, 0x0574	; 0x800574 <TIM0_PTR>
    1f66:	f0 91 75 05 	lds	r31, 0x0575	; 0x800575 <TIM0_PTR+0x1>
    1f6a:	09 95       	icall


}
    1f6c:	ff 91       	pop	r31
    1f6e:	ef 91       	pop	r30
    1f70:	bf 91       	pop	r27
    1f72:	af 91       	pop	r26
    1f74:	9f 91       	pop	r25
    1f76:	8f 91       	pop	r24
    1f78:	7f 91       	pop	r23
    1f7a:	6f 91       	pop	r22
    1f7c:	5f 91       	pop	r21
    1f7e:	4f 91       	pop	r20
    1f80:	3f 91       	pop	r19
    1f82:	2f 91       	pop	r18
    1f84:	0f 90       	pop	r0
    1f86:	0f be       	out	0x3f, r0	; 63
    1f88:	0f 90       	pop	r0
    1f8a:	1f 90       	pop	r1
    1f8c:	18 95       	reti

00001f8e <__vector_10>:

void __vector_10(void)__attribute__((signal)) ;
void __vector_10(void){
    1f8e:	1f 92       	push	r1
    1f90:	0f 92       	push	r0
    1f92:	0f b6       	in	r0, 0x3f	; 63
    1f94:	0f 92       	push	r0
    1f96:	11 24       	eor	r1, r1
    1f98:	2f 93       	push	r18
    1f9a:	3f 93       	push	r19
    1f9c:	4f 93       	push	r20
    1f9e:	5f 93       	push	r21
    1fa0:	6f 93       	push	r22
    1fa2:	7f 93       	push	r23
    1fa4:	8f 93       	push	r24
    1fa6:	9f 93       	push	r25
    1fa8:	af 93       	push	r26
    1faa:	bf 93       	push	r27
    1fac:	ef 93       	push	r30
    1fae:	ff 93       	push	r31
	

	TIM0_PTR[1]() ;
    1fb0:	e0 91 76 05 	lds	r30, 0x0576	; 0x800576 <TIM0_PTR+0x2>
    1fb4:	f0 91 77 05 	lds	r31, 0x0577	; 0x800577 <TIM0_PTR+0x3>
    1fb8:	09 95       	icall

}
    1fba:	ff 91       	pop	r31
    1fbc:	ef 91       	pop	r30
    1fbe:	bf 91       	pop	r27
    1fc0:	af 91       	pop	r26
    1fc2:	9f 91       	pop	r25
    1fc4:	8f 91       	pop	r24
    1fc6:	7f 91       	pop	r23
    1fc8:	6f 91       	pop	r22
    1fca:	5f 91       	pop	r21
    1fcc:	4f 91       	pop	r20
    1fce:	3f 91       	pop	r19
    1fd0:	2f 91       	pop	r18
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63
    1fd6:	0f 90       	pop	r0
    1fd8:	1f 90       	pop	r1
    1fda:	18 95       	reti

00001fdc <UART_voidInit>:
	/* SET DATA */
	UDR_REG=copy_u8data ; 
	while(GET_BIT(UCSRA_REG,5)==0) ; 
	
	
}
    1fdc:	86 e8       	ldi	r24, 0x86	; 134
    1fde:	80 bd       	out	0x20, r24	; 32
    1fe0:	87 e6       	ldi	r24, 0x67	; 103
    1fe2:	89 b9       	out	0x09, r24	; 9
    1fe4:	8a b1       	in	r24, 0x0a	; 10
    1fe6:	88 60       	ori	r24, 0x08	; 8
    1fe8:	8a b9       	out	0x0a, r24	; 10
    1fea:	8a b1       	in	r24, 0x0a	; 10
    1fec:	80 61       	ori	r24, 0x10	; 16
    1fee:	8a b9       	out	0x0a, r24	; 10
    1ff0:	08 95       	ret

00001ff2 <UART_u8RX>:
u8 UART_u8RX(void) {
	
	while(GET_BIT(UCSRA_REG,7)==0) ; 
    1ff2:	5f 9b       	sbis	0x0b, 7	; 11
    1ff4:	fe cf       	rjmp	.-4      	; 0x1ff2 <UART_u8RX>
	
	return UDR_REG ;  // RETURN VALUE 
    1ff6:	8c b1       	in	r24, 0x0c	; 12
    1ff8:	08 95       	ret

00001ffa <__fixunssfsi>:
    1ffa:	0e 94 71 10 	call	0x20e2	; 0x20e2 <__fp_splitA>
    1ffe:	88 f0       	brcs	.+34     	; 0x2022 <__fixunssfsi+0x28>
    2000:	9f 57       	subi	r25, 0x7F	; 127
    2002:	98 f0       	brcs	.+38     	; 0x202a <__fixunssfsi+0x30>
    2004:	b9 2f       	mov	r27, r25
    2006:	99 27       	eor	r25, r25
    2008:	b7 51       	subi	r27, 0x17	; 23
    200a:	b0 f0       	brcs	.+44     	; 0x2038 <__fixunssfsi+0x3e>
    200c:	e1 f0       	breq	.+56     	; 0x2046 <__fixunssfsi+0x4c>
    200e:	66 0f       	add	r22, r22
    2010:	77 1f       	adc	r23, r23
    2012:	88 1f       	adc	r24, r24
    2014:	99 1f       	adc	r25, r25
    2016:	1a f0       	brmi	.+6      	; 0x201e <__fixunssfsi+0x24>
    2018:	ba 95       	dec	r27
    201a:	c9 f7       	brne	.-14     	; 0x200e <__fixunssfsi+0x14>
    201c:	14 c0       	rjmp	.+40     	; 0x2046 <__fixunssfsi+0x4c>
    201e:	b1 30       	cpi	r27, 0x01	; 1
    2020:	91 f0       	breq	.+36     	; 0x2046 <__fixunssfsi+0x4c>
    2022:	0e 94 8b 10 	call	0x2116	; 0x2116 <__fp_zero>
    2026:	b1 e0       	ldi	r27, 0x01	; 1
    2028:	08 95       	ret
    202a:	0c 94 8b 10 	jmp	0x2116	; 0x2116 <__fp_zero>
    202e:	67 2f       	mov	r22, r23
    2030:	78 2f       	mov	r23, r24
    2032:	88 27       	eor	r24, r24
    2034:	b8 5f       	subi	r27, 0xF8	; 248
    2036:	39 f0       	breq	.+14     	; 0x2046 <__fixunssfsi+0x4c>
    2038:	b9 3f       	cpi	r27, 0xF9	; 249
    203a:	cc f3       	brlt	.-14     	; 0x202e <__fixunssfsi+0x34>
    203c:	86 95       	lsr	r24
    203e:	77 95       	ror	r23
    2040:	67 95       	ror	r22
    2042:	b3 95       	inc	r27
    2044:	d9 f7       	brne	.-10     	; 0x203c <__fixunssfsi+0x42>
    2046:	3e f4       	brtc	.+14     	; 0x2056 <__fixunssfsi+0x5c>
    2048:	90 95       	com	r25
    204a:	80 95       	com	r24
    204c:	70 95       	com	r23
    204e:	61 95       	neg	r22
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	8f 4f       	sbci	r24, 0xFF	; 255
    2054:	9f 4f       	sbci	r25, 0xFF	; 255
    2056:	08 95       	ret

00002058 <__floatunsisf>:
    2058:	e8 94       	clt
    205a:	09 c0       	rjmp	.+18     	; 0x206e <__floatsisf+0x12>

0000205c <__floatsisf>:
    205c:	97 fb       	bst	r25, 7
    205e:	3e f4       	brtc	.+14     	; 0x206e <__floatsisf+0x12>
    2060:	90 95       	com	r25
    2062:	80 95       	com	r24
    2064:	70 95       	com	r23
    2066:	61 95       	neg	r22
    2068:	7f 4f       	sbci	r23, 0xFF	; 255
    206a:	8f 4f       	sbci	r24, 0xFF	; 255
    206c:	9f 4f       	sbci	r25, 0xFF	; 255
    206e:	99 23       	and	r25, r25
    2070:	a9 f0       	breq	.+42     	; 0x209c <__floatsisf+0x40>
    2072:	f9 2f       	mov	r31, r25
    2074:	96 e9       	ldi	r25, 0x96	; 150
    2076:	bb 27       	eor	r27, r27
    2078:	93 95       	inc	r25
    207a:	f6 95       	lsr	r31
    207c:	87 95       	ror	r24
    207e:	77 95       	ror	r23
    2080:	67 95       	ror	r22
    2082:	b7 95       	ror	r27
    2084:	f1 11       	cpse	r31, r1
    2086:	f8 cf       	rjmp	.-16     	; 0x2078 <__floatsisf+0x1c>
    2088:	fa f4       	brpl	.+62     	; 0x20c8 <__floatsisf+0x6c>
    208a:	bb 0f       	add	r27, r27
    208c:	11 f4       	brne	.+4      	; 0x2092 <__floatsisf+0x36>
    208e:	60 ff       	sbrs	r22, 0
    2090:	1b c0       	rjmp	.+54     	; 0x20c8 <__floatsisf+0x6c>
    2092:	6f 5f       	subi	r22, 0xFF	; 255
    2094:	7f 4f       	sbci	r23, 0xFF	; 255
    2096:	8f 4f       	sbci	r24, 0xFF	; 255
    2098:	9f 4f       	sbci	r25, 0xFF	; 255
    209a:	16 c0       	rjmp	.+44     	; 0x20c8 <__floatsisf+0x6c>
    209c:	88 23       	and	r24, r24
    209e:	11 f0       	breq	.+4      	; 0x20a4 <__floatsisf+0x48>
    20a0:	96 e9       	ldi	r25, 0x96	; 150
    20a2:	11 c0       	rjmp	.+34     	; 0x20c6 <__floatsisf+0x6a>
    20a4:	77 23       	and	r23, r23
    20a6:	21 f0       	breq	.+8      	; 0x20b0 <__floatsisf+0x54>
    20a8:	9e e8       	ldi	r25, 0x8E	; 142
    20aa:	87 2f       	mov	r24, r23
    20ac:	76 2f       	mov	r23, r22
    20ae:	05 c0       	rjmp	.+10     	; 0x20ba <__floatsisf+0x5e>
    20b0:	66 23       	and	r22, r22
    20b2:	71 f0       	breq	.+28     	; 0x20d0 <__floatsisf+0x74>
    20b4:	96 e8       	ldi	r25, 0x86	; 134
    20b6:	86 2f       	mov	r24, r22
    20b8:	70 e0       	ldi	r23, 0x00	; 0
    20ba:	60 e0       	ldi	r22, 0x00	; 0
    20bc:	2a f0       	brmi	.+10     	; 0x20c8 <__floatsisf+0x6c>
    20be:	9a 95       	dec	r25
    20c0:	66 0f       	add	r22, r22
    20c2:	77 1f       	adc	r23, r23
    20c4:	88 1f       	adc	r24, r24
    20c6:	da f7       	brpl	.-10     	; 0x20be <__floatsisf+0x62>
    20c8:	88 0f       	add	r24, r24
    20ca:	96 95       	lsr	r25
    20cc:	87 95       	ror	r24
    20ce:	97 f9       	bld	r25, 7
    20d0:	08 95       	ret

000020d2 <__fp_split3>:
    20d2:	57 fd       	sbrc	r21, 7
    20d4:	90 58       	subi	r25, 0x80	; 128
    20d6:	44 0f       	add	r20, r20
    20d8:	55 1f       	adc	r21, r21
    20da:	59 f0       	breq	.+22     	; 0x20f2 <__fp_splitA+0x10>
    20dc:	5f 3f       	cpi	r21, 0xFF	; 255
    20de:	71 f0       	breq	.+28     	; 0x20fc <__fp_splitA+0x1a>
    20e0:	47 95       	ror	r20

000020e2 <__fp_splitA>:
    20e2:	88 0f       	add	r24, r24
    20e4:	97 fb       	bst	r25, 7
    20e6:	99 1f       	adc	r25, r25
    20e8:	61 f0       	breq	.+24     	; 0x2102 <__fp_splitA+0x20>
    20ea:	9f 3f       	cpi	r25, 0xFF	; 255
    20ec:	79 f0       	breq	.+30     	; 0x210c <__fp_splitA+0x2a>
    20ee:	87 95       	ror	r24
    20f0:	08 95       	ret
    20f2:	12 16       	cp	r1, r18
    20f4:	13 06       	cpc	r1, r19
    20f6:	14 06       	cpc	r1, r20
    20f8:	55 1f       	adc	r21, r21
    20fa:	f2 cf       	rjmp	.-28     	; 0x20e0 <__fp_split3+0xe>
    20fc:	46 95       	lsr	r20
    20fe:	f1 df       	rcall	.-30     	; 0x20e2 <__fp_splitA>
    2100:	08 c0       	rjmp	.+16     	; 0x2112 <__fp_splitA+0x30>
    2102:	16 16       	cp	r1, r22
    2104:	17 06       	cpc	r1, r23
    2106:	18 06       	cpc	r1, r24
    2108:	99 1f       	adc	r25, r25
    210a:	f1 cf       	rjmp	.-30     	; 0x20ee <__fp_splitA+0xc>
    210c:	86 95       	lsr	r24
    210e:	71 05       	cpc	r23, r1
    2110:	61 05       	cpc	r22, r1
    2112:	08 94       	sec
    2114:	08 95       	ret

00002116 <__fp_zero>:
    2116:	e8 94       	clt

00002118 <__fp_szero>:
    2118:	bb 27       	eor	r27, r27
    211a:	66 27       	eor	r22, r22
    211c:	77 27       	eor	r23, r23
    211e:	cb 01       	movw	r24, r22
    2120:	97 f9       	bld	r25, 7
    2122:	08 95       	ret

00002124 <__gesf2>:
    2124:	0e 94 04 11 	call	0x2208	; 0x2208 <__fp_cmp>
    2128:	08 f4       	brcc	.+2      	; 0x212c <__gesf2+0x8>
    212a:	8f ef       	ldi	r24, 0xFF	; 255
    212c:	08 95       	ret

0000212e <__mulsf3>:
    212e:	0e 94 aa 10 	call	0x2154	; 0x2154 <__mulsf3x>
    2132:	0c 94 3f 11 	jmp	0x227e	; 0x227e <__fp_round>
    2136:	0e 94 31 11 	call	0x2262	; 0x2262 <__fp_pscA>
    213a:	38 f0       	brcs	.+14     	; 0x214a <__mulsf3+0x1c>
    213c:	0e 94 38 11 	call	0x2270	; 0x2270 <__fp_pscB>
    2140:	20 f0       	brcs	.+8      	; 0x214a <__mulsf3+0x1c>
    2142:	95 23       	and	r25, r21
    2144:	11 f0       	breq	.+4      	; 0x214a <__mulsf3+0x1c>
    2146:	0c 94 28 11 	jmp	0x2250	; 0x2250 <__fp_inf>
    214a:	0c 94 2e 11 	jmp	0x225c	; 0x225c <__fp_nan>
    214e:	11 24       	eor	r1, r1
    2150:	0c 94 8c 10 	jmp	0x2118	; 0x2118 <__fp_szero>

00002154 <__mulsf3x>:
    2154:	0e 94 69 10 	call	0x20d2	; 0x20d2 <__fp_split3>
    2158:	70 f3       	brcs	.-36     	; 0x2136 <__mulsf3+0x8>

0000215a <__mulsf3_pse>:
    215a:	95 9f       	mul	r25, r21
    215c:	c1 f3       	breq	.-16     	; 0x214e <__mulsf3+0x20>
    215e:	95 0f       	add	r25, r21
    2160:	50 e0       	ldi	r21, 0x00	; 0
    2162:	55 1f       	adc	r21, r21
    2164:	62 9f       	mul	r22, r18
    2166:	f0 01       	movw	r30, r0
    2168:	72 9f       	mul	r23, r18
    216a:	bb 27       	eor	r27, r27
    216c:	f0 0d       	add	r31, r0
    216e:	b1 1d       	adc	r27, r1
    2170:	63 9f       	mul	r22, r19
    2172:	aa 27       	eor	r26, r26
    2174:	f0 0d       	add	r31, r0
    2176:	b1 1d       	adc	r27, r1
    2178:	aa 1f       	adc	r26, r26
    217a:	64 9f       	mul	r22, r20
    217c:	66 27       	eor	r22, r22
    217e:	b0 0d       	add	r27, r0
    2180:	a1 1d       	adc	r26, r1
    2182:	66 1f       	adc	r22, r22
    2184:	82 9f       	mul	r24, r18
    2186:	22 27       	eor	r18, r18
    2188:	b0 0d       	add	r27, r0
    218a:	a1 1d       	adc	r26, r1
    218c:	62 1f       	adc	r22, r18
    218e:	73 9f       	mul	r23, r19
    2190:	b0 0d       	add	r27, r0
    2192:	a1 1d       	adc	r26, r1
    2194:	62 1f       	adc	r22, r18
    2196:	83 9f       	mul	r24, r19
    2198:	a0 0d       	add	r26, r0
    219a:	61 1d       	adc	r22, r1
    219c:	22 1f       	adc	r18, r18
    219e:	74 9f       	mul	r23, r20
    21a0:	33 27       	eor	r19, r19
    21a2:	a0 0d       	add	r26, r0
    21a4:	61 1d       	adc	r22, r1
    21a6:	23 1f       	adc	r18, r19
    21a8:	84 9f       	mul	r24, r20
    21aa:	60 0d       	add	r22, r0
    21ac:	21 1d       	adc	r18, r1
    21ae:	82 2f       	mov	r24, r18
    21b0:	76 2f       	mov	r23, r22
    21b2:	6a 2f       	mov	r22, r26
    21b4:	11 24       	eor	r1, r1
    21b6:	9f 57       	subi	r25, 0x7F	; 127
    21b8:	50 40       	sbci	r21, 0x00	; 0
    21ba:	9a f0       	brmi	.+38     	; 0x21e2 <__mulsf3_pse+0x88>
    21bc:	f1 f0       	breq	.+60     	; 0x21fa <__mulsf3_pse+0xa0>
    21be:	88 23       	and	r24, r24
    21c0:	4a f0       	brmi	.+18     	; 0x21d4 <__mulsf3_pse+0x7a>
    21c2:	ee 0f       	add	r30, r30
    21c4:	ff 1f       	adc	r31, r31
    21c6:	bb 1f       	adc	r27, r27
    21c8:	66 1f       	adc	r22, r22
    21ca:	77 1f       	adc	r23, r23
    21cc:	88 1f       	adc	r24, r24
    21ce:	91 50       	subi	r25, 0x01	; 1
    21d0:	50 40       	sbci	r21, 0x00	; 0
    21d2:	a9 f7       	brne	.-22     	; 0x21be <__mulsf3_pse+0x64>
    21d4:	9e 3f       	cpi	r25, 0xFE	; 254
    21d6:	51 05       	cpc	r21, r1
    21d8:	80 f0       	brcs	.+32     	; 0x21fa <__mulsf3_pse+0xa0>
    21da:	0c 94 28 11 	jmp	0x2250	; 0x2250 <__fp_inf>
    21de:	0c 94 8c 10 	jmp	0x2118	; 0x2118 <__fp_szero>
    21e2:	5f 3f       	cpi	r21, 0xFF	; 255
    21e4:	e4 f3       	brlt	.-8      	; 0x21de <__mulsf3_pse+0x84>
    21e6:	98 3e       	cpi	r25, 0xE8	; 232
    21e8:	d4 f3       	brlt	.-12     	; 0x21de <__mulsf3_pse+0x84>
    21ea:	86 95       	lsr	r24
    21ec:	77 95       	ror	r23
    21ee:	67 95       	ror	r22
    21f0:	b7 95       	ror	r27
    21f2:	f7 95       	ror	r31
    21f4:	e7 95       	ror	r30
    21f6:	9f 5f       	subi	r25, 0xFF	; 255
    21f8:	c1 f7       	brne	.-16     	; 0x21ea <__mulsf3_pse+0x90>
    21fa:	fe 2b       	or	r31, r30
    21fc:	88 0f       	add	r24, r24
    21fe:	91 1d       	adc	r25, r1
    2200:	96 95       	lsr	r25
    2202:	87 95       	ror	r24
    2204:	97 f9       	bld	r25, 7
    2206:	08 95       	ret

00002208 <__fp_cmp>:
    2208:	99 0f       	add	r25, r25
    220a:	00 08       	sbc	r0, r0
    220c:	55 0f       	add	r21, r21
    220e:	aa 0b       	sbc	r26, r26
    2210:	e0 e8       	ldi	r30, 0x80	; 128
    2212:	fe ef       	ldi	r31, 0xFE	; 254
    2214:	16 16       	cp	r1, r22
    2216:	17 06       	cpc	r1, r23
    2218:	e8 07       	cpc	r30, r24
    221a:	f9 07       	cpc	r31, r25
    221c:	c0 f0       	brcs	.+48     	; 0x224e <__fp_cmp+0x46>
    221e:	12 16       	cp	r1, r18
    2220:	13 06       	cpc	r1, r19
    2222:	e4 07       	cpc	r30, r20
    2224:	f5 07       	cpc	r31, r21
    2226:	98 f0       	brcs	.+38     	; 0x224e <__fp_cmp+0x46>
    2228:	62 1b       	sub	r22, r18
    222a:	73 0b       	sbc	r23, r19
    222c:	84 0b       	sbc	r24, r20
    222e:	95 0b       	sbc	r25, r21
    2230:	39 f4       	brne	.+14     	; 0x2240 <__fp_cmp+0x38>
    2232:	0a 26       	eor	r0, r26
    2234:	61 f0       	breq	.+24     	; 0x224e <__fp_cmp+0x46>
    2236:	23 2b       	or	r18, r19
    2238:	24 2b       	or	r18, r20
    223a:	25 2b       	or	r18, r21
    223c:	21 f4       	brne	.+8      	; 0x2246 <__fp_cmp+0x3e>
    223e:	08 95       	ret
    2240:	0a 26       	eor	r0, r26
    2242:	09 f4       	brne	.+2      	; 0x2246 <__fp_cmp+0x3e>
    2244:	a1 40       	sbci	r26, 0x01	; 1
    2246:	a6 95       	lsr	r26
    2248:	8f ef       	ldi	r24, 0xFF	; 255
    224a:	81 1d       	adc	r24, r1
    224c:	81 1d       	adc	r24, r1
    224e:	08 95       	ret

00002250 <__fp_inf>:
    2250:	97 f9       	bld	r25, 7
    2252:	9f 67       	ori	r25, 0x7F	; 127
    2254:	80 e8       	ldi	r24, 0x80	; 128
    2256:	70 e0       	ldi	r23, 0x00	; 0
    2258:	60 e0       	ldi	r22, 0x00	; 0
    225a:	08 95       	ret

0000225c <__fp_nan>:
    225c:	9f ef       	ldi	r25, 0xFF	; 255
    225e:	80 ec       	ldi	r24, 0xC0	; 192
    2260:	08 95       	ret

00002262 <__fp_pscA>:
    2262:	00 24       	eor	r0, r0
    2264:	0a 94       	dec	r0
    2266:	16 16       	cp	r1, r22
    2268:	17 06       	cpc	r1, r23
    226a:	18 06       	cpc	r1, r24
    226c:	09 06       	cpc	r0, r25
    226e:	08 95       	ret

00002270 <__fp_pscB>:
    2270:	00 24       	eor	r0, r0
    2272:	0a 94       	dec	r0
    2274:	12 16       	cp	r1, r18
    2276:	13 06       	cpc	r1, r19
    2278:	14 06       	cpc	r1, r20
    227a:	05 06       	cpc	r0, r21
    227c:	08 95       	ret

0000227e <__fp_round>:
    227e:	09 2e       	mov	r0, r25
    2280:	03 94       	inc	r0
    2282:	00 0c       	add	r0, r0
    2284:	11 f4       	brne	.+4      	; 0x228a <__fp_round+0xc>
    2286:	88 23       	and	r24, r24
    2288:	52 f0       	brmi	.+20     	; 0x229e <__fp_round+0x20>
    228a:	bb 0f       	add	r27, r27
    228c:	40 f4       	brcc	.+16     	; 0x229e <__fp_round+0x20>
    228e:	bf 2b       	or	r27, r31
    2290:	11 f4       	brne	.+4      	; 0x2296 <__fp_round+0x18>
    2292:	60 ff       	sbrs	r22, 0
    2294:	04 c0       	rjmp	.+8      	; 0x229e <__fp_round+0x20>
    2296:	6f 5f       	subi	r22, 0xFF	; 255
    2298:	7f 4f       	sbci	r23, 0xFF	; 255
    229a:	8f 4f       	sbci	r24, 0xFF	; 255
    229c:	9f 4f       	sbci	r25, 0xFF	; 255
    229e:	08 95       	ret

000022a0 <__udivmodhi4>:
    22a0:	aa 1b       	sub	r26, r26
    22a2:	bb 1b       	sub	r27, r27
    22a4:	51 e1       	ldi	r21, 0x11	; 17
    22a6:	07 c0       	rjmp	.+14     	; 0x22b6 <__udivmodhi4_ep>

000022a8 <__udivmodhi4_loop>:
    22a8:	aa 1f       	adc	r26, r26
    22aa:	bb 1f       	adc	r27, r27
    22ac:	a6 17       	cp	r26, r22
    22ae:	b7 07       	cpc	r27, r23
    22b0:	10 f0       	brcs	.+4      	; 0x22b6 <__udivmodhi4_ep>
    22b2:	a6 1b       	sub	r26, r22
    22b4:	b7 0b       	sbc	r27, r23

000022b6 <__udivmodhi4_ep>:
    22b6:	88 1f       	adc	r24, r24
    22b8:	99 1f       	adc	r25, r25
    22ba:	5a 95       	dec	r21
    22bc:	a9 f7       	brne	.-22     	; 0x22a8 <__udivmodhi4_loop>
    22be:	80 95       	com	r24
    22c0:	90 95       	com	r25
    22c2:	bc 01       	movw	r22, r24
    22c4:	cd 01       	movw	r24, r26
    22c6:	08 95       	ret

000022c8 <__udivmodsi4>:
    22c8:	a1 e2       	ldi	r26, 0x21	; 33
    22ca:	1a 2e       	mov	r1, r26
    22cc:	aa 1b       	sub	r26, r26
    22ce:	bb 1b       	sub	r27, r27
    22d0:	fd 01       	movw	r30, r26
    22d2:	0d c0       	rjmp	.+26     	; 0x22ee <__udivmodsi4_ep>

000022d4 <__udivmodsi4_loop>:
    22d4:	aa 1f       	adc	r26, r26
    22d6:	bb 1f       	adc	r27, r27
    22d8:	ee 1f       	adc	r30, r30
    22da:	ff 1f       	adc	r31, r31
    22dc:	a2 17       	cp	r26, r18
    22de:	b3 07       	cpc	r27, r19
    22e0:	e4 07       	cpc	r30, r20
    22e2:	f5 07       	cpc	r31, r21
    22e4:	20 f0       	brcs	.+8      	; 0x22ee <__udivmodsi4_ep>
    22e6:	a2 1b       	sub	r26, r18
    22e8:	b3 0b       	sbc	r27, r19
    22ea:	e4 0b       	sbc	r30, r20
    22ec:	f5 0b       	sbc	r31, r21

000022ee <__udivmodsi4_ep>:
    22ee:	66 1f       	adc	r22, r22
    22f0:	77 1f       	adc	r23, r23
    22f2:	88 1f       	adc	r24, r24
    22f4:	99 1f       	adc	r25, r25
    22f6:	1a 94       	dec	r1
    22f8:	69 f7       	brne	.-38     	; 0x22d4 <__udivmodsi4_loop>
    22fa:	60 95       	com	r22
    22fc:	70 95       	com	r23
    22fe:	80 95       	com	r24
    2300:	90 95       	com	r25
    2302:	9b 01       	movw	r18, r22
    2304:	ac 01       	movw	r20, r24
    2306:	bd 01       	movw	r22, r26
    2308:	cf 01       	movw	r24, r30
    230a:	08 95       	ret

0000230c <memcmp>:
    230c:	fb 01       	movw	r30, r22
    230e:	dc 01       	movw	r26, r24
    2310:	04 c0       	rjmp	.+8      	; 0x231a <memcmp+0xe>
    2312:	8d 91       	ld	r24, X+
    2314:	01 90       	ld	r0, Z+
    2316:	80 19       	sub	r24, r0
    2318:	21 f4       	brne	.+8      	; 0x2322 <memcmp+0x16>
    231a:	41 50       	subi	r20, 0x01	; 1
    231c:	50 40       	sbci	r21, 0x00	; 0
    231e:	c8 f7       	brcc	.-14     	; 0x2312 <memcmp+0x6>
    2320:	88 1b       	sub	r24, r24
    2322:	99 0b       	sbc	r25, r25
    2324:	08 95       	ret

00002326 <memcpy>:
    2326:	fb 01       	movw	r30, r22
    2328:	dc 01       	movw	r26, r24
    232a:	02 c0       	rjmp	.+4      	; 0x2330 <memcpy+0xa>
    232c:	01 90       	ld	r0, Z+
    232e:	0d 92       	st	X+, r0
    2330:	41 50       	subi	r20, 0x01	; 1
    2332:	50 40       	sbci	r21, 0x00	; 0
    2334:	d8 f7       	brcc	.-10     	; 0x232c <memcpy+0x6>
    2336:	08 95       	ret

00002338 <_exit>:
    2338:	f8 94       	cli

0000233a <__stop_program>:
    233a:	ff cf       	rjmp	.-2      	; 0x233a <__stop_program>
